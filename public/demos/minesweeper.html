<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper AI - Tony Rodr√≠guez</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(to bottom right, #111827, #1e3a8a, #312e81);
            min-height: 100vh;
        }
        
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
            z-index: 1000;
            padding: 0;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
        }
        
        .header-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }
        
        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 80px;
        }
        
        .logo {
            font-weight: bold;
            font-size: 1.25rem;
            color: #ffffff;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        .logo:hover {
            color: #60a5fa;
        }
        
        .nav-desktop {
            display: none;
        }
        
        .nav-mobile {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .language-selector {
            position: relative;
            display: inline-block;
        }
        
        .language-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            background: transparent;
            border: none;
            color: #d1d5db;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .language-btn:hover {
            background-color: rgba(96, 165, 250, 0.2);
        }
        
        .language-dropdown {
            position: absolute;
            right: 0;
            top: 100%;
            margin-top: 0.5rem;
            width: 12rem;
            background: rgba(17, 24, 39, 0.95);
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.3);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            z-index: 50;
        }
        
        .language-selector:hover .language-dropdown {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .language-option {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            font-size: 0.875rem;
            color: #d1d5db;
            cursor: pointer;
            transition: background-color 0.3s ease;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }
        
        .language-option:hover {
            background-color: rgba(96, 165, 250, 0.2);
        }
        
        .language-option.active {
            background-color: rgba(96, 165, 250, 0.2);
            color: #60a5fa;
        }
        
        .language-option.active::after {
            content: "‚úì";
            margin-left: auto;
            color: #60a5fa;
        }
        
        .mobile-menu-btn {
            padding: 0.5rem;
            border-radius: 0.5rem;
            background: transparent;
            border: none;
            color: #374151;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .mobile-menu-btn:hover {
            background-color: rgba(102, 126, 234, 0.1);
        }
        
        .mobile-menu {
            display: none;
            border-top: 1px solid rgba(102, 126, 234, 0.1);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
        }
        
        .mobile-menu.open {
            display: block;
        }
        
        .mobile-nav {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .mobile-nav-link {
            display: block;
            padding: 0.75rem 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: #6b7280;
            text-decoration: none;
            border-radius: 0.5rem;
            transition: all 0.3s ease;
        }
        
        .mobile-nav-link:hover {
            color: #667eea;
            background-color: rgba(102, 126, 234, 0.1);
        }
        
        .mobile-nav-link.active {
            color: #667eea;
            background-color: rgba(102, 126, 234, 0.1);
        }
        
        .nav-link {
            font-size: 0.875rem;
            font-weight: 500;
            color: #6b7280;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        .nav-link:hover {
            color: #667eea;
        }
        
        .nav-link.active {
            color: #667eea;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 2rem;
            font-weight: 600;
            font-size: 0.875rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        @media (min-width: 768px) {
            .nav-desktop {
                display: flex;
                align-items: center;
                gap: 2rem;
            }
            
            .nav-mobile {
                display: none;
            }
            
            .header-container {
                padding: 0 1.5rem;
            }
        }
        
        .back-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            border: none;
            cursor: pointer;
        }
        
        .back-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
        }
        
        .back-btn:active {
            transform: translateY(-1px);
        }
        
        .game-title {
            font-size: 20px;
            font-weight: 700;
            color: #2d3748;
            margin: 0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .main-content {
            padding-top: 100px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 100px clamp(10px, 3vw, 20px) 20px;
        }
        
        .container {
            background: rgba(17, 24, 39, 0.95);
            border-radius: 20px;
            padding: clamp(20px, 5vw, 40px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 800px;
            width: 100%;
            margin: 10px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            backdrop-filter: blur(20px);
        }
        
        h1 {
            color: #ffffff;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #d1d5db;
            margin-bottom: 30px;
        }
        
        .game-container {
            margin: 30px 0;
            padding: 20px;
            background: rgba(31, 41, 55, 0.8);
            border-radius: 15px;
            border: 1px solid rgba(59, 130, 246, 0.1);
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
            color: white;
            border: 1px solid rgba(59, 130, 246, 0.3);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            background: linear-gradient(135deg, #1d4ed8 0%, #2563eb 100%);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .board {
            display: grid;
            gap: 2px;
            margin: 20px auto;
            background: #333;
            padding: 10px;
            border-radius: 10px;
            max-width: fit-content;
            width: 100%;
            max-width: min(90vw, 400px);
        }
        
        .cell {
            width: 100%;
            aspect-ratio: 1;
            min-width: 20px;
            max-width: 35px;
            background: rgba(44, 57, 77, 0.9);
            border: 1px solid rgba(51, 123, 238, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(10px, 3vw, 14px);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s;
            color: #ffffff;
        }
        
        .cell:hover {
            background: rgba(59, 130, 246, 0.2);
            transform: scale(1.05);
        }
        
        .cell.revealed {
            background: rgba(31, 41, 55, 0.9);
            cursor: default;
        }
        
        .cell.mine {
            background: #f87171;
            color: white;
        }
        
        .cell.flagged {
            background: #60a5fa;
            color: white;
        }
        
        .cell.number-1 { color: #60a5fa; }
        .cell.number-2 { color: #34d399; }
        .cell.number-3 { color: #f87171; }
        .cell.number-4 { color: #a78bfa; }
        .cell.number-5 { color: #fbbf24; }
        .cell.number-6 { color: #22d3ee; }
        .cell.number-7 { color: #6b7280; }
        .cell.number-8 { color: #9ca3af; }
        
        .status {
            margin: 20px 0;
            font-size: 18px;
            font-weight: bold;
            color: #8a99b6;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
        }
        
        .stat {
            background: rgba(31, 41, 55, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(59, 130, 246, 0.1);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #60a5fa;
        }
        
        .stat-label {
            font-size: 14px;
            color: #d1d5db;
            margin-top: 5px;
        }
        
        
        .ai-info h3 {
            color: #60a5fa;
            margin-bottom: 10px;
        }
        
        .ai-info p {
            color: #9ca3af;
            margin: 5px 0;
        }
        
        .ai-info strong {
            color: #60a5fa;
        }
        
        .ai-info {
            color: #9ca3af;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-container">
            <div class="header-content">
                <!-- Logo -->
                <a href="/" class="logo">Tony Rodr√≠guez</a>
                
                <!-- Desktop Navigation -->
                <nav class="nav-desktop">
                    <a href="/" class="nav-link">Home</a>
                    <a href="/about" class="nav-link">About</a>
                    <a href="/projects" class="nav-link">Projects</a>
                    <a href="/resume" class="nav-link">Resume</a>
                    <a href="/ai" class="nav-link active">AI Lab</a>
                    <a href="/contact" class="nav-link">Contact</a>
                </nav>
                
                <!-- Desktop Actions -->
                <div class="nav-desktop">
                    <div class="language-selector">
                        <button class="language-btn">
                            <span>üåê</span>
                            <span id="current-lang">EN</span>
                        </button>
                        <div class="language-dropdown">
                            <button class="language-option active" data-lang="en">EN</button>
                            <button class="language-option" data-lang="es">ES</button>
                            <button class="language-option" data-lang="ca">CAT</button>
                        </div>
                    </div>
                    <a href="/contact" class="btn-primary">Hire Me</a>
                </div>
                
                <!-- Mobile Menu -->
                <div class="nav-mobile">
                    <div class="language-selector">
                        <button class="language-btn">
                            <span>üåê</span>
                            <span id="current-lang-mobile">EN</span>
                        </button>
                        <div class="language-dropdown">
                            <button class="language-option active" data-lang="en">EN</button>
                            <button class="language-option" data-lang="es">ES</button>
                            <button class="language-option" data-lang="ca">CAT</button>
                        </div>
                    </div>
                    <button class="mobile-menu-btn" id="mobile-menu-btn">
                        <span id="menu-icon">‚ò∞</span>
                    </button>
                </div>
            </div>
            
            <!-- Mobile Navigation -->
            <div class="mobile-menu" id="mobile-menu">
                <nav class="mobile-nav">
                    <a href="/" class="mobile-nav-link">Home</a>
                    <a href="/about" class="mobile-nav-link">About</a>
                    <a href="/projects" class="mobile-nav-link">Projects</a>
                    <a href="/resume" class="mobile-nav-link">Resume</a>
                    <a href="/ai" class="mobile-nav-link active">AI Lab</a>
                    <a href="/contact" class="mobile-nav-link">Contact</a>
                </nav>
            </div>
        </div>
    </header>
    
    <div class="main-content">
        <div class="container">
            <h1>üí£ Minesweeper AI</h1>
        <p class="subtitle">Watch the AI solve Minesweeper puzzles using logical deduction</p>
        
        <div class="game-container">
            <div class="controls">
                <button onclick="newGame()">New Game</button>
                <button onclick="toggleAIMode()" id="aiBtn">Enable AI</button>
                <button onclick="aiSolveStep()" id="solveBtn" disabled>AI Solve Step</button>
                <button onclick="aiSolveAll()" id="solveAllBtn" disabled>AI Solve All</button>
            </div>
            
            <div class="status" id="status">Click a cell to start!</div>
            
            <div class="board" id="board"></div>
            
            <div class="ai-info">
                <strong>AI Features:</strong> This AI uses Tony's original logical deduction implementation converted from Python to JavaScript. 
                It uses Sentence objects and knowledge base inference to solve Minesweeper puzzles intelligently.
            </div>
            
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="games">0</div>
                    <div class="stat-label">Games Played</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="wins">0</div>
                    <div class="stat-label">Wins</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="aiMoves">0</div>
                    <div class="stat-label">AI Moves</div>
                </div>
            </div>
        </div>
        </div>
    </div>
    
    <script>
        // Tony's Minesweeper AI Implementation (JavaScript version)
        
        // Minesweeper game representation
        class Minesweeper {
            constructor(height = 8, width = 8, mines = 8) {
                this.height = height;
                this.width = width;
                this.mines = new Set();
                
                // Initialize an empty field with no mines
                this.board = [];
                for (let i = 0; i < this.height; i++) {
                    let row = [];
                    for (let j = 0; j < this.width; j++) {
                        row.push(false);
                    }
                    this.board.push(row);
                }
                
                // Add mines randomly
                while (this.mines.size !== mines) {
                    let i = Math.floor(Math.random() * height);
                    let j = Math.floor(Math.random() * width);
                    if (!this.board[i][j]) {
                        this.mines.add([i, j]);
                        this.board[i][j] = true;
                    }
                }
                
                // At first, player has found no mines
                this.mines_found = new Set();
            }
            
            isMine(cell) {
                let [i, j] = cell;
                return this.board[i][j];
            }
            
            nearbyMines(cell) {
                // Keep count of nearby mines
                let count = 0;
                
                // Loop over all cells within one row and column
                for (let i = cell[0] - 1; i < cell[0] + 2; i++) {
                    for (let j = cell[1] - 1; j < cell[1] + 2; j++) {
                        // Ignore the cell itself
                        if (i === cell[0] && j === cell[1]) {
                            continue;
                        }
                        
                        // Update count if cell in bounds and is mine
                        if (i >= 0 && i < this.height && j >= 0 && j < this.width) {
                            if (this.board[i][j]) {
                                count++;
                            }
                        }
                    }
                }
                
                return count;
            }
            
            won() {
                // Checks if all mines have been flagged
                return this.mines_found.size === this.mines.size && 
                       [...this.mines_found].every(mine => 
                           [...this.mines].some(m => m[0] === mine[0] && m[1] === mine[1])
                       );
            }
        }
        
        // Logical statement about a Minesweeper game
        class Sentence {
            constructor(cells, count) {
                this.cells = new Set(cells);
                this.count = count;
            }
            
            equals(other) {
                return this.cells.size === other.cells.size && 
                       [...this.cells].every(cell => other.cells.has(cell)) &&
                       this.count === other.count;
            }
            
            knownMines() {
                // If count equals the number of cells, all cells are mines
                if (this.count === this.cells.size) {
                    return new Set(this.cells);
                }
                return new Set();
            }
            
            knownSafes() {
                // If count is 0, all cells are safe
                if (this.count === 0) {
                    return new Set(this.cells);
                }
                return new Set();
            }
            
            markMine(cell) {
                // Updates internal knowledge representation given the fact that
                // a cell is known to be a mine.
                if (this.cells.has(cell)) {
                    this.cells.delete(cell);
                    this.count--;
                }
            }
            
            markSafe(cell) {
                // Updates internal knowledge representation given the fact that
                // a cell is known to be safe.
                if (this.cells.has(cell)) {
                    this.cells.delete(cell);
                }
            }
        }
        
        // Minesweeper game player
        class MinesweeperAI {
            constructor(height = 8, width = 8) {
                // Set initial height and width
                this.height = height;
                this.width = width;
                
                // Keep track of which cells have been clicked on
                this.movesMade = new Set();
                
                // Keep track of cells known to be safe or mines
                this.mines = new Set();
                this.safes = new Set();
                
                // List of sentences about the game known to be true
                this.knowledge = [];
            }
            
            markMine(cell) {
                // Marks a cell as a mine, and updates all knowledge
                // to mark that cell as a mine as well.
                this.mines.add(cell);
                for (let sentence of this.knowledge) {
                    sentence.markMine(cell);
                }
            }
            
            markSafe(cell) {
                // Marks a cell as safe, and updates all knowledge
                // to mark that cell as safe as well.
                this.safes.add(cell);
                for (let sentence of this.knowledge) {
                    sentence.markSafe(cell);
                }
            }
            
            addKnowledge(cell, count) {
                // Called when the Minesweeper board tells us, for a given
                // safe cell, how many neighboring cells have mines in them.
                
                // 1) Mark the cell as a move that has been made
                this.movesMade.add(cell);
                
                // 2) Mark the cell as safe
                this.markSafe(cell);
                
                // 3) Add a new sentence to the AI's knowledge base
                // Get all neighboring cells
                let neighbors = new Set();
                for (let i = cell[0] - 1; i < cell[0] + 2; i++) {
                    for (let j = cell[1] - 1; j < cell[1] + 2; j++) {
                        // Ignore the cell itself
                        if (i === cell[0] && j === cell[1]) {
                            continue;
                        }
                        // Only include cells that are in bounds and not already known
                        if (i >= 0 && i < this.height && j >= 0 && j < this.width) {
                            neighbors.add([i, j]);
                        }
                    }
                }
                
                // Only include cells whose state is still undetermined
                let undeterminedNeighbors = new Set();
                for (let neighbor of neighbors) {
                    let isKnown = false;
                    for (let mine of this.mines) {
                        if (mine[0] === neighbor[0] && mine[1] === neighbor[1]) {
                            isKnown = true;
                            break;
                        }
                    }
                    if (!isKnown) {
                        for (let safe of this.safes) {
                            if (safe[0] === neighbor[0] && safe[1] === neighbor[1]) {
                                isKnown = true;
                                break;
                            }
                        }
                    }
                    if (!isKnown) {
                        undeterminedNeighbors.add(neighbor);
                    }
                }
                
                // Add the new sentence to knowledge
                if (undeterminedNeighbors.size > 0) {
                    let newSentence = new Sentence(undeterminedNeighbors, count);
                    this.knowledge.push(newSentence);
                }
                
                // 4) Mark any additional cells as safe or as mines
                // Keep updating until no more changes can be made
                let changed = true;
                while (changed) {
                    changed = false;
                    
                    // Check each sentence for known mines and safes
                    for (let sentence of this.knowledge) {
                        let knownMines = sentence.knownMines();
                        let knownSafes = sentence.knownSafes();
                        
                        // Mark known mines
                        for (let mine of knownMines) {
                            let isAlreadyKnown = false;
                            for (let knownMine of this.mines) {
                                if (knownMine[0] === mine[0] && knownMine[1] === mine[1]) {
                                    isAlreadyKnown = true;
                                    break;
                                }
                            }
                            if (!isAlreadyKnown) {
                                this.markMine(mine);
                                changed = true;
                            }
                        }
                        
                        // Mark known safes
                        for (let safe of knownSafes) {
                            let isAlreadyKnown = false;
                            for (let knownSafe of this.safes) {
                                if (knownSafe[0] === safe[0] && knownSafe[1] === safe[1]) {
                                    isAlreadyKnown = true;
                                    break;
                                }
                            }
                            if (!isAlreadyKnown) {
                                this.markSafe(safe);
                                changed = true;
                            }
                        }
                    }
                    
                    // 5) Add any new sentences that can be inferred
                    // Check for subset relationships
                    for (let sentence1 of this.knowledge) {
                        for (let sentence2 of this.knowledge) {
                            if (!sentence1.equals(sentence2)) {
                                // If sentence1 is a subset of sentence2
                                let isSubset = true;
                                for (let cell of sentence1.cells) {
                                    let found = false;
                                    for (let cell2 of sentence2.cells) {
                                        if (cell[0] === cell2[0] && cell[1] === cell2[1]) {
                                            found = true;
                                            break;
                                        }
                                    }
                                    if (!found) {
                                        isSubset = false;
                                        break;
                                    }
                                }
                                
                                if (isSubset) {
                                    // Create new sentence: sentence2 - sentence1 = count2 - count1
                                    let newCells = new Set();
                                    for (let cell of sentence2.cells) {
                                        let found = false;
                                        for (let cell1 of sentence1.cells) {
                                            if (cell[0] === cell1[0] && cell[1] === cell1[1]) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        if (!found) {
                                            newCells.add(cell);
                                        }
                                    }
                                    
                                    let newCount = sentence2.count - sentence1.count;
                                    
                                    if (newCells.size > 0 && newCount >= 0) {
                                        let newSentence = new Sentence(newCells, newCount);
                                        // Only add if it's not already in knowledge
                                        let alreadyExists = false;
                                        for (let existing of this.knowledge) {
                                            if (existing.equals(newSentence)) {
                                                alreadyExists = true;
                                                break;
                                            }
                                        }
                                        if (!alreadyExists) {
                                            this.knowledge.push(newSentence);
                                            changed = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            makeSafeMove() {
                // Returns a safe cell to choose on the Minesweeper board.
                // The move must be known to be safe, and not already a move
                // that has been made.
                
                // Find safe cells that haven't been moved on yet
                let safeMoves = new Set();
                for (let safe of this.safes) {
                    let alreadyMoved = false;
                    for (let move of this.movesMade) {
                        if (move[0] === safe[0] && move[1] === safe[1]) {
                            alreadyMoved = true;
                            break;
                        }
                    }
                    if (!alreadyMoved) {
                        safeMoves.add(safe);
                    }
                }
                
                if (safeMoves.size > 0) {
                    return [...safeMoves][0]; // Return any safe move
                }
                return null;
            }
            
            makeRandomMove() {
                // Returns a move to make on the Minesweeper board.
                // Should choose randomly among cells that:
                // 1) have not already been chosen, and
                // 2) are not known to be mines
                
                // Get all possible cells
                let allCells = new Set();
                for (let i = 0; i < this.height; i++) {
                    for (let j = 0; j < this.width; j++) {
                        allCells.add([i, j]);
                    }
                }
                
                // Remove cells that have been moved on or are known mines
                let possibleMoves = new Set();
                for (let cell of allCells) {
                    let alreadyMoved = false;
                    for (let move of this.movesMade) {
                        if (move[0] === cell[0] && move[1] === cell[1]) {
                            alreadyMoved = true;
                            break;
                        }
                    }
                    
                    let isKnownMine = false;
                    for (let mine of this.mines) {
                        if (mine[0] === cell[0] && mine[1] === cell[1]) {
                            isKnownMine = true;
                            break;
                        }
                    }
                    
                    if (!alreadyMoved && !isKnownMine) {
                        possibleMoves.add(cell);
                    }
                }
                
                if (possibleMoves.size > 0) {
                    let moves = [...possibleMoves];
                    return moves[Math.floor(Math.random() * moves.length)];
                }
                return null;
            }
        }
        
        // Game state
        let game = null;
        let ai = null;
        let gameActive = true;
        let aiMode = false;
        let stats = { games: 0, wins: 0, aiMoves: 0 };
        
        const BOARD_SIZE = 9;
        const MINE_COUNT = 10;
        
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const aiBtn = document.getElementById('aiBtn');
        const solveBtn = document.getElementById('solveBtn');
        const solveAllBtn = document.getElementById('solveAllBtn');
        
        function initBoard() {
            game = new Minesweeper(BOARD_SIZE, BOARD_SIZE, MINE_COUNT);
            ai = new MinesweeperAI(BOARD_SIZE, BOARD_SIZE);
            
            boardElement.innerHTML = '';
            boardElement.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, 1fr)`;
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.addEventListener('click', () => handleCellClick(i, j));
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        handleRightClick(i, j);
                    });
                    boardElement.appendChild(cell);
                }
            }
        }
        
        function handleCellClick(row, col) {
            if (!gameActive) return;
            
            const cell = [row, col];
            
            if (game.isMine(cell)) {
                gameOver(false);
                return;
            }
            
            revealCell(row, col);
            
            if (game.won()) {
                gameOver(true);
            }
        }
        
        function handleRightClick(row, col) {
            if (!gameActive) return;
            
            const cell = [row, col];
            const cellElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            
            if (cellElement.classList.contains('flagged')) {
                cellElement.classList.remove('flagged');
                cellElement.textContent = '';
                game.mines_found.delete(cell);
            } else {
                cellElement.classList.add('flagged');
                cellElement.textContent = 'üö©';
                game.mines_found.add(cell);
            }
        }
        
        function revealCell(row, col) {
            const cell = [row, col];
            const cellElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            
            if (cellElement.classList.contains('revealed')) return;
            
            cellElement.classList.add('revealed');
            
            const count = game.nearbyMines(cell);
            if (count > 0) {
                cellElement.textContent = count;
                cellElement.classList.add(`number-${count}`);
            } else {
                cellElement.textContent = '';
                // Reveal neighbors recursively
                for (let i = row - 1; i <= row + 1; i++) {
                    for (let j = col - 1; j <= col + 1; j++) {
                        if (i >= 0 && i < BOARD_SIZE && j >= 0 && j < BOARD_SIZE) {
                            revealCell(i, j);
                        }
                    }
                }
            }
            
            // Update AI knowledge
            if (aiMode) {
                ai.addKnowledge(cell, count);
            }
        }
        
        function gameOver(won) {
            gameActive = false;
            
            // Reveal all mines
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (game.board[i][j]) {
                        const cellElement = document.querySelector(`[data-row="${i}"][data-col="${j}"]`);
                        cellElement.classList.add('mine');
                        cellElement.textContent = 'üí£';
                    }
                }
            }
            
            if (won) {
                statusElement.textContent = 'üéâ You won!';
                stats.wins++;
            } else {
                statusElement.textContent = 'üí• Game Over!';
            }
            
            stats.games++;
            updateStats();
        }
        
        function newGame() {
            gameActive = true;
            initBoard();
            statusElement.textContent = 'Click a cell to start!';
        }
        
        function toggleAIMode() {
            aiMode = !aiMode;
            solveBtn.disabled = !aiMode;
            solveAllBtn.disabled = !aiMode;
            aiBtn.textContent = aiMode ? 'Disable AI' : 'Enable AI';
            statusElement.textContent = aiMode ? 'AI Mode Enabled' : 'AI Mode Disabled';
            
            if (aiMode) {
                ai = new MinesweeperAI(BOARD_SIZE, BOARD_SIZE);
            }
        }
        
        function aiSolveStep() {
            if (!aiMode || !gameActive) return;
            
            // Try to make a safe move first
            let safeMove = ai.makeSafeMove();
            if (safeMove) {
                revealCell(safeMove[0], safeMove[1]);
                stats.aiMoves++;
                updateStats();
                return;
            }
            
            // If no safe move, make a random move
            let randomMove = ai.makeRandomMove();
            if (randomMove) {
                revealCell(randomMove[0], randomMove[1]);
                stats.aiMoves++;
                updateStats();
            } else {
                statusElement.textContent = 'No more moves available for AI';
            }
        }
        
        function aiSolveAll() {
            if (!aiMode || !gameActive) return;
            
            let movesMade = true;
            while (movesMade && gameActive) {
                movesMade = false;
                
                // Try to make a safe move first
                let safeMove = ai.makeSafeMove();
                if (safeMove) {
                    revealCell(safeMove[0], safeMove[1]);
                    stats.aiMoves++;
                    movesMade = true;
                    continue;
                }
                
                // If no safe move, make a random move
                let randomMove = ai.makeRandomMove();
                if (randomMove) {
                    revealCell(randomMove[0], randomMove[1]);
                    stats.aiMoves++;
                    movesMade = true;
                }
            }
            
            updateStats();
        }
        
        function updateStats() {
            document.getElementById('games').textContent = stats.games;
            document.getElementById('wins').textContent = stats.wins;
            document.getElementById('aiMoves').textContent = stats.aiMoves;
        }
        
        // Load stats from localStorage
        const savedStats = localStorage.getItem('minesweeper-stats');
        if (savedStats) {
            stats = JSON.parse(savedStats);
            updateStats();
        }
        
        // Save stats to localStorage
        window.addEventListener('beforeunload', () => {
            localStorage.setItem('minesweeper-stats', JSON.stringify(stats));
        });
        
        // Initialize game
        initBoard();
        
        // Translations
        const translations = {
            en: {
                title: 'Minesweeper AI',
                subtitle: 'Watch the AI solve Minesweeper puzzles using logical deduction',
                description: 'This AI uses Tony\'s original logical deduction implementation converted from Python to JavaScript. The algorithm analyzes patterns and probabilities to make safe moves and solve puzzles efficiently.',
                stats: {
                    games: 'Games',
                    aiMoves: 'AI Moves',
                    winRate: 'Win Rate'
                },
                game: {
                    clickToStart: 'Click a cell to start!',
                    aiSolving: 'AI is solving...',
                    gameWon: 'Game won!',
                    gameLost: 'Game lost!',
                    newGame: 'New Game',
                    resetStats: 'Reset Stats',
                    aiMode: 'AI Mode',
                    manualMode: 'Manual Mode'
                },
                nav: {
                    home: 'Home',
                    about: 'About',
                    projects: 'Projects',
                    resume: 'Resume',
                    aiLab: 'AI Lab',
                    contact: 'Contact',
                    hireMe: 'Hire Me'
                }
            },
            es: {
                title: 'Buscaminas IA',
                subtitle: 'Observa c√≥mo la IA resuelve puzzles de Buscaminas usando deducci√≥n l√≥gica',
                description: 'Esta IA utiliza la implementaci√≥n original de deducci√≥n l√≥gica de Tony convertida de Python a JavaScript. El algoritmo analiza patrones y probabilidades para hacer movimientos seguros y resolver puzzles eficientemente.',
                stats: {
                    games: 'Partidas',
                    aiMoves: 'Movimientos IA',
                    winRate: 'Tasa de Victoria'
                },
                game: {
                    clickToStart: '¬°Haz clic en una celda para empezar!',
                    aiSolving: 'La IA est√° resolviendo...',
                    gameWon: '¬°Partida ganada!',
                    gameLost: '¬°Partida perdida!',
                    newGame: 'Nueva Partida',
                    resetStats: 'Reiniciar Estad√≠sticas',
                    aiMode: 'Modo IA',
                    manualMode: 'Modo Manual'
                },
                nav: {
                    home: 'Inicio',
                    about: 'Acerca de',
                    projects: 'Proyectos',
                    resume: 'CV',
                    aiLab: 'Laboratorio de IA',
                    contact: 'Contacto',
                    hireMe: 'Contr√°tame'
                }
            },
            ca: {
                title: 'Buscaminas IA',
                subtitle: 'Observa com la IA resol els puzzles de Buscaminas utilitzant deducci√≥ l√≤gica',
                description: 'Aquesta IA utilitza la implementaci√≥ original de deducci√≥ l√≤gica de Tony convertida de Python a JavaScript. L\'algoritme analitza patrons i probabilitats per fer moviments segurs i resoldre puzzles eficientment.',
                stats: {
                    games: 'Partides',
                    aiMoves: 'Moviments IA',
                    winRate: 'Taxa de Vict√≤ria'
                },
                game: {
                    clickToStart: 'Fes clic en una cel¬∑la per comen√ßar!',
                    aiSolving: 'La IA est√† resolent...',
                    gameWon: 'Partida guanyada!',
                    gameLost: 'Partida perduda!',
                    newGame: 'Nova Partida',
                    resetStats: 'Reiniciar Estad√≠stiques',
                    aiMode: 'Mode IA',
                    manualMode: 'Mode Manual'
                },
                nav: {
                    home: 'Inici',
                    about: 'Sobre mi',
                    projects: 'Projectes',
                    resume: 'CV',
                    aiLab: 'Laboratori d\'IA',
                    contact: 'Contacte',
                    hireMe: 'Contracta\'m'
                }
            }
        };
        
        // Language functions
        function updateContent(language) {
            const t = translations[language];
            
            // Update title and subtitle
            document.querySelector('h1').textContent = t.title;
            document.querySelector('.subtitle').textContent = t.subtitle;
            
            // Update description
            document.querySelector('p[style*="color: #666"]').textContent = t.description;
            
            // Update navigation
            document.querySelectorAll('.nav-link').forEach((link, index) => {
                const navKeys = ['home', 'about', 'projects', 'resume', 'aiLab', 'contact'];
                if (navKeys[index]) {
                    link.textContent = t.nav[navKeys[index]];
                }
            });
            
            document.querySelectorAll('.mobile-nav-link').forEach((link, index) => {
                const navKeys = ['home', 'about', 'projects', 'resume', 'aiLab', 'contact'];
                if (navKeys[index]) {
                    link.textContent = t.nav[navKeys[index]];
                }
            });
            
            // Update Hire Me button
            document.querySelector('.btn-primary').textContent = t.nav.hireMe;
            
            // Update stats labels
            document.querySelector('.stat:nth-child(1) .stat-label').textContent = t.stats.games;
            document.querySelector('.stat:nth-child(2) .stat-label').textContent = t.stats.aiMoves;
            document.querySelector('.stat:nth-child(3) .stat-label').textContent = t.stats.winRate;
        }
            // Mobile menu toggle
            const mobileMenuBtn = document.getElementById('mobile-menu-btn');
            const mobileMenu = document.getElementById('mobile-menu');
            const menuIcon = document.getElementById('menu-icon');
            
            if (mobileMenuBtn && mobileMenu) {
                mobileMenuBtn.addEventListener('click', function() {
                    mobileMenu.classList.toggle('open');
                    menuIcon.textContent = mobileMenu.classList.contains('open') ? '‚úï' : '‚ò∞';
                });
            }
            
            // Language selector functionality
            const languageOptions = document.querySelectorAll('.language-option');
            const currentLangElements = document.querySelectorAll('#current-lang, #current-lang-mobile');
            
            // Get current language from localStorage or default to 'en'
            let currentLanguage = localStorage.getItem('selected-language') || 'en';
            
            // Update language display
            function updateLanguageDisplay() {
                const langMap = { 'en': 'EN', 'es': 'ES', 'ca': 'CAT' };
                currentLangElements.forEach(el => {
                    el.textContent = langMap[currentLanguage] || 'EN';
                });
                
                // Update active state
                languageOptions.forEach(option => {
                    option.classList.remove('active');
                    if (option.dataset.lang === currentLanguage) {
                        option.classList.add('active');
                    }
                });
            }
            
            // Language change handler
            languageOptions.forEach(option => {
                option.addEventListener('click', function() {
                    currentLanguage = this.dataset.lang;
                    localStorage.setItem('selected-language', currentLanguage);
                    updateLanguageDisplay();
                    updateContent(currentLanguage);
                    
                    // Close mobile menu if open
                    if (mobileMenu.classList.contains('open')) {
                        mobileMenu.classList.remove('open');
                        menuIcon.textContent = '‚ò∞';
                    }
                });
            });
            
            // Initialize language display
            updateLanguageDisplay();
            
            // Initialize content with current language
            updateContent(currentLanguage);
        });
    </script>
</body>
</html>
