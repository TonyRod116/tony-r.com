<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MNIST Neural Network Visualization</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
      background: #111827;
      color: white;
      overflow-x: hidden;
    }
    /* Site header - matches main app header (dark) */
    .site-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      transition: background 0.3s, border-color 0.3s;
      background: rgba(17, 24, 39, 0.7);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(55, 65, 81, 0.5);
    }
    .site-header.scrolled {
      background: rgba(17, 24, 39, 0.9);
      border-bottom-color: #374151;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    .site-header .header-inner {
      max-width: 1800px;
      margin: 0 auto;
      padding: 0 16px;
    }
    @media (min-width: 640px) {
      .site-header .header-inner { padding: 0 24px; }
    }
    @media (min-width: 1024px) {
      .site-header .header-inner { padding: 0 32px; }
    }
    .site-header .header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 80px;
    }
    .site-header .header-left {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      min-width: 0;
    }
    .site-header .header-center {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .site-header .header-right {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      min-width: 0;
    }
    .site-header .logo {
      font-weight: 700;
      font-size: 0.875rem;
      color: #fff;
      text-decoration: none;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.2));
    }
    .site-header .logo:hover {
      color: #fff;
    }
    .site-header .nav-desktop {
      display: none;
    }
    @media (min-width: 768px) {
      .site-header .nav-desktop {
        display: flex;
        align-items: center;
        gap: 24px;
      }
    }
    @media (min-width: 1024px) {
      .site-header .nav-desktop { gap: 32px; }
    }
    .site-header .nav-desktop a {
      font-size: 0.875rem;
      font-weight: 500;
      color: #e5e7eb;
      text-decoration: none;
      transition: color 0.2s;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.2));
    }
    .site-header .nav-desktop a:hover {
      color: #2563eb;
    }
    .site-header .nav-desktop a.active {
      color: #2563eb;
    }
    /* Language selector */
    .site-header .lang-wrap {
      position: relative;
    }
    .site-header .lang-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 8px;
      background: transparent;
      border: none;
      color: #fff;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }
    .site-header .lang-btn:hover {
      background: rgba(55, 65, 81, 0.8);
    }
    .site-header .lang-btn svg {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }
    .site-header .lang-btn .lang-globe {
      stroke-width: 2;
    }
    .site-header .lang-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 8px;
      width: 192px;
      background: #1f2937;
      border: 1px solid #374151;
      border-radius: 8px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.3);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
      z-index: 50;
      overflow: hidden;
    }
    .site-header .lang-wrap:hover .lang-dropdown,
    .site-header .lang-wrap.open .lang-dropdown {
      opacity: 1;
      visibility: visible;
    }
    .site-header .lang-dropdown button {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      padding: 10px 16px;
      font-size: 0.875rem;
      color: #e5e7eb;
      background: transparent;
      border: none;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      text-align: left;
    }
    .site-header .lang-dropdown button:hover {
      background: rgba(55, 65, 81, 0.8);
      color: #2563eb;
    }
    .site-header .lang-dropdown button.active {
      background: rgba(37, 99, 235, 0.2);
      color: #2563eb;
    }
    .site-header .lang-dropdown button.active::after {
      content: '✓';
      color: #2563eb;
    }
    .site-header .lang-desktop {
      display: none;
    }
    @media (min-width: 768px) {
      .site-header .lang-desktop { display: block; }
    }
    .site-header .mobile-toggle {
      display: flex;
      align-items: center;
      padding: 8px;
      border-radius: 8px;
      background: transparent;
      border: none;
      color: #e5e7eb;
      cursor: pointer;
      transition: background 0.2s;
    }
    .site-header .mobile-toggle:hover {
      background: rgba(55, 65, 81, 0.8);
    }
    @media (min-width: 768px) {
      .site-header .mobile-toggle { display: none; }
    }
    .site-header .mobile-toggle svg {
      width: 20px;
      height: 20px;
    }
    /* Mobile menu overlay */
    .site-header .mobile-overlay {
      display: none;
      position: fixed;
      inset: 0;
      top: 80px;
      background: rgba(0,0,0,0.3);
      backdrop-filter: blur(4px);
      z-index: 9998;
    }
    .site-header .mobile-overlay.open {
      display: block;
    }
    @media (min-width: 768px) {
      .site-header .mobile-overlay { display: none !important; }
    }
    /* Mobile menu panel */
    .site-header .mobile-panel {
      position: fixed;
      top: 80px;
      right: 0;
      width: 256px;
      max-width: 70vw;
      max-height: calc(100vh - 80px);
      background: rgba(17, 24, 39, 0.98);
      backdrop-filter: blur(12px);
      border-left: 1px solid #374151;
      box-shadow: -4px 0 24px rgba(0,0,0,0.3);
      z-index: 9999;
      padding: 16px 0;
      overflow-y: auto;
      transform: translateX(100%);
      transition: transform 0.3s ease-out;
    }
    .site-header .mobile-panel.open {
      transform: translateX(0);
    }
    @media (min-width: 768px) {
      .site-header .mobile-panel { display: none !important; }
    }
    .site-header .mobile-panel a {
      display: block;
      padding: 10px 16px;
      margin: 0 8px;
      font-size: 0.875rem;
      font-weight: 500;
      color: #d1d5db;
      text-decoration: none;
      border-radius: 6px;
      transition: color 0.2s, background 0.2s;
    }
    .site-header .mobile-panel a:hover {
      color: #2563eb;
      background: rgba(55, 65, 81, 0.5);
    }
    .site-header .mobile-panel a.active {
      color: #2563eb;
      background: rgba(37, 99, 235, 0.15);
    }
    .site-header .mobile-panel .lang-mobile {
      padding: 16px;
      border-top: 1px solid #374151;
      margin-top: 8px;
    }
    .site-header .mobile-panel .lang-mobile .lang-label {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-bottom: 8px;
    }
    .site-header .mobile-panel .lang-mobile-btns {
      display: flex;
      gap: 8px;
    }
    .site-header .mobile-panel .lang-mobile-btns button {
      padding: 8px 12px;
      font-size: 0.875rem;
      border-radius: 6px;
      border: 1px solid #374151;
      background: rgba(55, 65, 81, 0.5);
      color: #e5e7eb;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    .site-header .mobile-panel .lang-mobile-btns button:hover,
    .site-header .mobile-panel .lang-mobile-btns button.active {
      background: rgba(37, 99, 235, 0.2);
      color: #2563eb;
      border-color: #2563eb;
    }
    /* Legacy .header / .header-content for any refs - keep main-content padding consistent */
    .header { display: none; }
    .header-content { display: none; }
    .main-content {
      padding-top: 80px;
      min-height: 100vh;
      position: relative;
      z-index: 10;
      pointer-events: none;
    }
    /* Only specific interactive elements block events */
    .panel, .title, .education-section {
      pointer-events: auto;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 24px;
      position: relative;
      z-index: 10;
      pointer-events: none;
    }
    .title {
      text-align: center;
      margin-bottom: 32px;
      position: relative;
      z-index: 10;
      pointer-events: none;
    }
    .title * {
      pointer-events: auto;
    }
    .title h1 {
      font-size: 2rem;
      font-weight: bold;
      margin-bottom: 8px;
    }
    .title p {
      color: #9ca3af;
    }
    .layout {
      display: grid;
      grid-template-columns: 320px 1fr 320px;
      gap: 24px;
      margin-bottom: 24px;
      position: relative;
      z-index: 10;
      pointer-events: none;
    }
    .layout > div:nth-child(2) {
      /* Middle column - empty, 3D visualization is in background */
      pointer-events: none;
    }
    .panel {
      background: rgba(31, 41, 55, 0.95);
      backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 16px;
      position: relative;
      z-index: 10;
      border: 1px solid rgba(55, 65, 81, 0.5);
    }
    .panel h2 {
      font-size: 1.125rem;
      font-weight: 600;
      margin-bottom: 16px;
    }
    #gridContainer {
      margin-bottom: 16px;
    }
    .btn {
      width: 100%;
      padding: 8px 16px;
      background: #374151;
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s;
    }
    .btn:hover {
      background: #4b5563;
    }
    .hint {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-top: 8px;
    }
    #threeContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #111827;
      z-index: 1;
      overflow: hidden;
    }
    #threeContainer canvas {
      pointer-events: auto !important;
      touch-action: none;
    }
    #predictionChart {
      margin-top: 24px;
    }
    @media (max-width: 1024px) {
      .layout {
        grid-template-columns: 1fr;
      }
      .layout > div:nth-child(2) {
        display: none;
      }
    }
    /* Educational Section Styles */
    .education-section {
      margin-top: 48px;
      position: relative;
      z-index: 10;
      pointer-events: none;
    }
    .education-section > * {
      pointer-events: auto;
    }
    .separator {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 64px;
    }
    .separator-line {
      flex: 1;
      height: 1px;
      background: linear-gradient(to right, transparent, #4b5563, transparent);
    }
    .separator-text {
      color: #6b7280;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 500;
    }
    .section {
      margin-bottom: 80px;
    }
    .section-title {
      font-size: 1.875rem;
      font-weight: bold;
      color: white;
      margin-bottom: 8px;
    }
    .section-subtitle {
      color: #9ca3af;
      margin-bottom: 32px;
    }
    .code-block {
      background: #0d1117;
      border: 1px solid rgba(55, 65, 81, 0.5);
      border-radius: 12px;
      overflow: hidden;
    }
    .code-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 16px;
      border-bottom: 1px solid rgba(55, 65, 81, 0.5);
    }
    .code-dots {
      display: flex;
      gap: 6px;
    }
    .code-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    .code-dot.red { background: rgba(239, 68, 68, 0.7); }
    .code-dot.yellow { background: rgba(234, 179, 8, 0.7); }
    .code-dot.green { background: rgba(34, 197, 94, 0.7); }
    .code-lang {
      font-size: 0.75rem;
      color: #6b7280;
      font-family: monospace;
    }
    .code-content {
      padding: 20px;
      overflow-x: auto;
      font-size: 0.875rem;
      line-height: 1.625;
      font-family: monospace;
    }
    .code-line {
      color: #d1d5db;
      min-height: 22px;
    }
    .code-line.annotated {
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(59, 130, 246, 0.05);
      margin: 0 -20px;
      padding: 0 20px;
      border-left: 2px solid rgba(59, 130, 246, 0.4);
    }
    .code-kw { color: #c084fc; }
    .code-fn { color: #60a5fa; }
    .code-str { color: #34d399; }
    .code-num { color: #fb923c; }
    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: rgba(59, 130, 246, 0.2);
      color: #60a5fa;
      font-size: 0.75rem;
      font-weight: bold;
      flex-shrink: 0;
    }
    .annotation-card {
      background: rgba(31, 41, 55, 0.5);
      backdrop-filter: blur(4px);
      border-radius: 8px;
      padding: 16px;
      border: 1px solid rgba(55, 65, 81, 0.5);
      border-left-width: 4px;
    }
    .annotation-card.blue { border-left-color: #3b82f6; }
    .annotation-card.green { border-left-color: #10b981; }
    .annotation-card.purple { border-left-color: #a855f7; }
    .annotation-card.orange { border-left-color: #f97316; }
    .annotation-card.red { border-left-color: #ef4444; }
    .annotation-content {
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }
    .annotation-text h4 {
      font-weight: 600;
      color: white;
      font-size: 0.875rem;
      margin-bottom: 4px;
    }
    .annotation-text p {
      color: #9ca3af;
      font-size: 0.875rem;
      line-height: 1.625;
    }
    .arch-diagram {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin-bottom: 48px;
    }
    .arch-box {
      background: linear-gradient(to bottom, rgba(37, 99, 235, 0.2), rgba(30, 64, 175, 0.2));
      border: 1px solid rgba(59, 130, 246, 0.5);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      min-width: 140px;
    }
    .arch-box.green {
      background: linear-gradient(to bottom, rgba(22, 163, 74, 0.2), rgba(20, 83, 45, 0.2));
      border-color: rgba(34, 197, 94, 0.5);
    }
    .arch-box.purple {
      background: linear-gradient(to bottom, rgba(147, 51, 234, 0.2), rgba(88, 28, 135, 0.2));
      border-color: rgba(168, 85, 247, 0.5);
    }
    .arch-label {
      font-size: 0.75rem;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 4px;
    }
    .arch-neurons {
      font-size: 1.875rem;
      font-weight: bold;
      color: white;
      margin-bottom: 4px;
    }
    .arch-sub {
      font-size: 0.875rem;
      color: #d1d5db;
    }
    .arch-arrow {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 8px;
      transform: rotate(90deg);
    }
    .arch-arrow-line {
      width: 24px;
      height: 2px;
      background: linear-gradient(to right, #3b82f6, #a855f7);
    }
    .arch-arrow-icon {
      width: 16px;
      height: 16px;
      color: #a855f7;
      margin-left: -4px;
    }
    .concept-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 24px;
    }
    .concept-card {
      background: rgba(31, 41, 55, 0.5);
      backdrop-filter: blur(4px);
      border-radius: 12px;
      padding: 24px;
      border: 1px solid rgba(55, 65, 81, 0.5);
    }
    .concept-icon {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
    }
    .concept-icon svg {
      width: 24px;
      height: 24px;
    }
    .concept-title {
      font-weight: 600;
      color: white;
      margin-bottom: 8px;
    }
    .concept-text {
      color: #9ca3af;
      font-size: 0.875rem;
      line-height: 1.625;
    }
    .pipeline-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
    }
    .pipeline-step {
      background: rgba(31, 41, 55, 0.5);
      backdrop-filter: blur(4px);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid rgba(55, 65, 81, 0.5);
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }
    .pipeline-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 12px;
    }
    .pipeline-icon svg {
      width: 20px;
      height: 20px;
    }
    .pipeline-num {
      font-size: 0.75rem;
      color: #6b7280;
      margin-bottom: 4px;
    }
    .pipeline-title {
      font-weight: 600;
      color: white;
      font-size: 0.875rem;
      margin-bottom: 8px;
    }
    .pipeline-text {
      color: #6b7280;
      font-size: 0.75rem;
      line-height: 1.5;
    }
    .expandable-card {
      background: rgba(31, 41, 55, 0.5);
      backdrop-filter: blur(4px);
      border-radius: 12px;
      border: 1px solid rgba(55, 65, 81, 0.5);
      border-left-width: 4px;
      overflow: hidden;
    }
    .expandable-header {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 20px;
      text-align: left;
      background: transparent;
      border: none;
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    }
    .expandable-header:hover {
      background: rgba(55, 65, 81, 0.2);
    }
    .expandable-title {
      font-weight: 600;
      color: white;
    }
    .expandable-icon {
      width: 16px;
      height: 16px;
      color: #9ca3af;
      flex-shrink: 0;
    }
    .expandable-content {
      padding: 0 20px 20px 20px;
      color: #d1d5db;
      font-size: 0.875rem;
      line-height: 1.625;
    }
    #epochSlider {
      -webkit-appearance: none;
      appearance: none;
      width: 100% !important;
      height: 8px !important;
      background: #374151 !important;
      border-radius: 4px;
      outline: none;
      margin: 12px 0;
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    #epochSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    #epochSlider::-webkit-slider-thumb:hover {
      background: #60a5fa;
      transform: scale(1.1);
    }
    #epochSlider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #3b82f6;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      transition: background 0.2s, transform 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    #epochSlider::-moz-range-thumb:hover {
      background: #60a5fa;
      transform: scale(1.1);
    }
    #epochSlider::-moz-range-track {
      height: 8px;
      background: #374151;
      border-radius: 4px;
    }
    #hiddenNodesSlider {
      -webkit-appearance: none;
      appearance: none;
      width: 100% !important;
      height: 8px !important;
      background: #374151 !important;
      border-radius: 4px;
      outline: none;
      margin: 12px 0;
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    #hiddenNodesSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #10b981;
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    #hiddenNodesSlider::-webkit-slider-thumb:hover {
      background: #34d399;
      transform: scale(1.1);
    }
    #hiddenNodesSlider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #10b981;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      transition: background 0.2s, transform 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    #hiddenNodesSlider::-moz-range-thumb:hover {
      background: #34d399;
      transform: scale(1.1);
    }
    #hiddenNodesSlider::-moz-range-track {
      height: 8px;
      background: #374151;
      border-radius: 4px;
    }
    @media (min-width: 1024px) {
      .arch-diagram {
        flex-direction: row;
      }
      .arch-arrow {
        transform: rotate(0deg);
      }
    }
  </style>
</head>
<body>
  <!-- 3D Network Visualization Background -->
  <div id="threeContainer"></div>
  
  <!-- Site header (matches main app, no React) -->
  <header class="site-header" id="siteHeader">
    <div class="header-inner">
      <div class="header-row">
        <div class="header-left">
          <a href="/" class="logo">Tony Rodríguez</a>
        </div>
        <div class="header-center">
          <nav class="nav-desktop" aria-label="Main">
            <a href="/">Home</a>
            <a href="/about">About</a>
            <a href="/projects">Projects</a>
            <a href="/ai" class="active">AI Lab</a>
            <a href="/demos">Demos</a>
            <a href="/resume">Resume</a>
            <a href="/contact">Contact</a>
          </nav>
        </div>
        <div class="header-right">
          <div class="lang-desktop lang-wrap" id="langWrap">
            <button type="button" class="lang-btn" id="langBtn" aria-label="Language" aria-expanded="false" aria-haspopup="true">
              <svg class="lang-globe" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10" />
                <path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20" />
                <path d="M2 12h20" />
              </svg>
              <span id="langCurrent">EN</span>
            </button>
            <div class="lang-dropdown" role="menu">
              <button type="button" role="menuitem" data-lang="en">EN</button>
              <button type="button" role="menuitem" data-lang="es">ES</button>
              <button type="button" role="menuitem" data-lang="ca">CAT</button>
            </div>
          </div>
          <button type="button" class="mobile-toggle" id="mobileMenuBtn" aria-label="Toggle menu">
            <svg id="menuIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
            </svg>
            <svg id="closeIcon" style="display:none;" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>
    </div>
    <div class="mobile-overlay" id="mobileOverlay" aria-hidden="true"></div>
    <nav class="mobile-panel" id="mobilePanel" aria-label="Mobile">
      <a href="/">Home</a>
      <a href="/about">About</a>
      <a href="/projects">Projects</a>
      <a href="/ai" class="active">AI Lab</a>
      <a href="/demos">Demos</a>
      <a href="/resume">Resume</a>
      <a href="/contact">Contact</a>
      <div class="lang-mobile">
        <div class="lang-label" data-i18n="langMobileLabel">Idioma / Language</div>
        <div class="lang-mobile-btns">
          <button type="button" data-lang="en">EN</button>
          <button type="button" data-lang="es">ES</button>
          <button type="button" data-lang="ca">CAT</button>
        </div>
      </div>
    </nav>
  </header>
  <script>
    (function () {
      var LANG_KEY = 'portfolio-language'
      var LANG_LABELS = { en: 'EN', es: 'ES', ca: 'CAT' }
      function getLang() {
        var s = localStorage.getItem(LANG_KEY)
        return (s === 'es' || s === 'ca') ? s : 'en'
      }
      function setLang(code) {
        localStorage.setItem(LANG_KEY, code)
        var cur = document.getElementById('langCurrent')
        if (cur) cur.textContent = LANG_LABELS[code] || code.toUpperCase()
        document.querySelectorAll('.lang-dropdown button[role="menuitem"], .lang-mobile-btns button').forEach(function (btn) {
          var lang = btn.getAttribute('data-lang')
          btn.classList.toggle('active', lang === code)
        })
        try { window.dispatchEvent(new CustomEvent('nn-lang-change', { detail: { lang: code } })) } catch (e) {}
      }
      var header = document.getElementById('siteHeader')
      var menuBtn = document.getElementById('mobileMenuBtn')
      var menuIcon = document.getElementById('menuIcon')
      var closeIcon = document.getElementById('closeIcon')
      var overlay = document.getElementById('mobileOverlay')
      var panel = document.getElementById('mobilePanel')
      setLang(getLang())
      var langWrap = document.getElementById('langWrap')
      var langBtn = document.getElementById('langBtn')
      if (langWrap && langBtn) {
        langBtn.addEventListener('click', function (e) {
          e.stopPropagation()
          langWrap.classList.toggle('open')
          langBtn.setAttribute('aria-expanded', langWrap.classList.contains('open'))
        })
        document.querySelectorAll('.lang-dropdown button[role="menuitem"]').forEach(function (btn) {
          btn.addEventListener('click', function () {
            setLang(btn.getAttribute('data-lang'))
            langWrap.classList.remove('open')
            langBtn.setAttribute('aria-expanded', 'false')
          })
        })
        document.addEventListener('click', function (e) {
          if (langWrap.contains(e.target)) return
          langWrap.classList.remove('open')
          langBtn.setAttribute('aria-expanded', 'false')
        })
      }
      panel.querySelectorAll('.lang-mobile-btns button').forEach(function (btn) {
        btn.addEventListener('click', function () {
          setLang(btn.getAttribute('data-lang'))
          closeMenu()
        })
      })
      function onScroll() {
        header.classList.toggle('scrolled', window.scrollY > 20)
      }
      function openMenu() {
        panel.classList.add('open')
        overlay.classList.add('open')
        overlay.setAttribute('aria-hidden', 'false')
        menuIcon.style.display = 'none'
        closeIcon.style.display = 'block'
      }
      function closeMenu() {
        panel.classList.remove('open')
        overlay.classList.remove('open')
        overlay.setAttribute('aria-hidden', 'true')
        menuIcon.style.display = 'block'
        closeIcon.style.display = 'none'
      }
      window.addEventListener('scroll', onScroll, { passive: true })
      onScroll()
      if (menuBtn) menuBtn.addEventListener('click', function () {
        if (panel.classList.contains('open')) closeMenu(); else openMenu()
      })
      if (overlay) overlay.addEventListener('click', closeMenu)
      panel.querySelectorAll('a').forEach(function (a) {
        a.addEventListener('click', closeMenu)
      })
    })()
  </script>

  <!-- Main Content -->
  <div class="main-content">
    <div class="container">
      <!-- Title -->
      <div class="title">
        <h1 data-i18n="heroTitle">MNIST Neural Network Visualization</h1>
        <p data-i18n="heroSubtitle">Draw a digit and watch how activations propagate through the network</p>
      </div>

      <!-- Main Layout -->
      <div class="layout">
        <!-- Left: Drawing Canvas and Prediction -->
        <div>
          <div class="panel">
            <h2 data-i18n="drawing">Drawing</h2>
            <div id="gridContainer"></div>
            <div style="margin-top: 16px;">
              <button id="resetBtn" class="btn" data-i18n="clear">Clear</button>
            </div>
            <p class="hint" data-i18n="hintDraw">Click and drag to draw (right-click to erase)</p>
          </div>

          <!-- Prediction Chart -->
          <div id="predictionChart" class="panel" style="margin-top: 24px;">
            <h2 data-i18n="prediction">Prediction</h2>
          </div>
        </div>

        <!-- Middle: 3D Visualization (background, handled by CSS) -->
        <div></div>

        <!-- Right: Controls -->
        <div>
          <!-- Epoch Slider -->
          <div class="panel" style="background: #1f2937; border-radius: 12px; padding: 16px;">
            <h2 style="font-size: 1.125rem; font-weight: 600; margin-bottom: 16px; color: white;" data-i18n="trainingEpoch">Training Epoch</h2>
            <div style="margin-bottom: 12px;">
              <input 
                type="range" 
                id="epochSlider" 
                min="0" 
                max="40" 
                value="40" 
                step="1"
              />
              <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 16px;">
                <div>
                  <div style="font-size: 0.875rem; color: #9ca3af; margin-bottom: 4px;" data-i18n="epoch">Epoch</div>
                  <div style="font-size: 1.5rem; font-weight: 600; color: white;" id="epochValue">40</div>
                </div>
                <div style="text-align: right;">
                  <div style="font-size: 0.875rem; color: #9ca3af; margin-bottom: 4px;" data-i18n="accuracy">Accuracy</div>
                  <div style="font-size: 1.5rem; font-weight: 600; color: #60a5fa;" id="accuracyValue">96.2%</div>
                </div>
              </div>
            </div>
            <p class="hint" data-i18n="hintEpoch">Adjust the epoch to see how training improves accuracy</p>
          </div>

          <!-- Hidden Nodes Slider -->
          <div class="panel" style="margin-top: 24px; background: #1f2937; border-radius: 12px; padding: 16px;">
            <h2 style="font-size: 1.125rem; font-weight: 600; margin-bottom: 16px; color: white;" data-i18n="hiddenLayerNodes">Hidden Layer Nodes</h2>
            <div style="margin-bottom: 12px;">
              <input 
                type="range" 
                id="hiddenNodesSlider" 
                min="16" 
                max="256" 
                value="64" 
                step="8"
              />
              <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 16px;">
                <div>
                  <div style="font-size: 0.875rem; color: #9ca3af; margin-bottom: 4px;" data-i18n="hiddenNodes">Hidden Nodes</div>
                  <div style="font-size: 1.5rem; font-weight: 600; color: white;" id="hiddenNodesValue">64</div>
                </div>
                <div style="text-align: right;">
                  <div style="font-size: 0.875rem; color: #9ca3af; margin-bottom: 4px;" data-i18n="accuracy">Accuracy</div>
                  <div style="font-size: 1.5rem; font-weight: 600; color: #60a5fa;" id="hiddenNodesAccuracyValue">96.2%</div>
                </div>
              </div>
            </div>
            <p class="hint" data-i18n="hintHidden">Adjust hidden layer size to see its impact on accuracy</p>
          </div>

          <!-- Update Visualization Button -->
          <div class="panel" style="margin-top: 24px; background: #1f2937; border-radius: 12px; padding: 16px;">
            <button id="updateVisualizationBtn" class="btn" style="background: #3b82f6; font-weight: 600;" data-i18n="updateBtn">
              Update and Recalculate
            </button>
            <p class="hint" style="margin-top: 8px;" data-i18n="hintUpdate">Click to update the 3D visualization and recalculate predictions</p>
          </div>
        </div>
      </div>

      <!-- Educational Content -->
      <div class="education-section">
        <!-- Separator -->
        <div class="separator">
          <div class="separator-line"></div>
          <span class="separator-text" data-i18n="learnMore">Learn More</span>
          <div class="separator-line"></div>
        </div>

        <!-- SECTION 1: Training Code -->
        <section class="section">
          <div>
            <h2 class="section-title" data-i18n="section1Title">How This Network Was Trained</h2>
            <p class="section-subtitle" data-i18n="section1Subtitle">The actual TensorFlow / Keras code used to build and train the model</p>
          </div>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px;">
            <!-- Code Block -->
            <div class="code-block">
              <div class="code-header">
                <div class="code-dots">
                  <div class="code-dot red"></div>
                  <div class="code-dot yellow"></div>
                  <div class="code-dot green"></div>
                </div>
                <span class="code-lang" data-i18n="codeLang">Python / TensorFlow</span>
              </div>
              <div class="code-content">
                <div class="code-line"><span class="code-kw">import</span> tensorflow <span class="code-kw">as</span> tf</div>
                <div class="code-line"><span class="code-kw">from</span> tensorflow.keras.layers <span class="code-kw">import</span> <span class="code-fn">Dense</span></div>
                <div class="code-line"></div>
                <div class="code-line">model = <span class="code-fn">Sequential</span>([</div>
                <div class="code-line annotated">
                  <span>  tf.keras.<span class="code-fn">Input</span>(shape=(<span class="code-num">784</span>,)),</span>
                  <span class="badge">1</span>
                </div>
                <div class="code-line annotated">
                  <span>  <span class="code-fn">Dense</span>(<span class="code-num">64</span>, activation=<span class="code-str">"relu"</span>),</span>
                  <span class="badge">2</span>
                </div>
                <div class="code-line annotated">
                  <span>  <span class="code-fn">Dense</span>(<span class="code-num">32</span>, activation=<span class="code-str">"relu"</span>),</span>
                  <span class="badge">3</span>
                </div>
                <div class="code-line annotated">
                  <span>  <span class="code-fn">Dense</span>(<span class="code-num">10</span>, activation=<span class="code-str">"softmax"</span>),</span>
                  <span class="badge">4</span>
                </div>
                <div class="code-line">])</div>
                <div class="code-line"></div>
                <div class="code-line annotated">
                  <span>model.<span class="code-fn">compile</span>(</span>
                  <span class="badge">5</span>
                </div>
                <div class="code-line">  loss=<span class="code-fn">SparseCategoricalCrossentropy</span>(),</div>
                <div class="code-line">  optimizer=<span class="code-fn">Adam</span>(<span class="code-num">0.001</span>),</div>
                <div class="code-line">)</div>
                <div class="code-line"></div>
                <div class="code-line annotated">
                  <span>model.<span class="code-fn">fit</span>(X, y, epochs=<span class="code-num">40</span>)</span>
                  <span class="badge">6</span>
                </div>
              </div>
            </div>

            <!-- Annotations -->
            <div style="display: flex; flex-direction: column; gap: 12px;">
              <div class="annotation-card blue">
                <div class="annotation-content">
                  <span class="badge">1</span>
                  <div class="annotation-text">
                    <h4 data-i18n="ann1Title">Input Layer</h4>
                    <p data-i18n="ann1Text">Each 28×28 pixel drawing is flattened into a vector of 784 numbers. This is the entry point of the network.</p>
                  </div>
                </div>
              </div>
              <div class="annotation-card green">
                <div class="annotation-content">
                  <span class="badge">2</span>
                  <div class="annotation-text">
                    <h4 data-i18n="ann2Title">Dense(64, relu)</h4>
                    <p data-i18n="ann2Text">A Dense (fully connected) layer: every one of the 64 neurons receives input from ALL 784 pixels. "Dense" means every possible connection exists. ReLU activation: if the value is negative → 0, if positive → passes through unchanged.</p>
                  </div>
                </div>
              </div>
              <div class="annotation-card green">
                <div class="annotation-content">
                  <span class="badge">3</span>
                  <div class="annotation-text">
                    <h4 data-i18n="ann3Title">Dense(32, relu)</h4>
                    <p data-i18n="ann3Text">Second hidden layer with 32 neurons, each connected to all 64 neurons from the previous layer. The network learns progressively more abstract patterns at each layer.</p>
                  </div>
                </div>
              </div>
              <div class="annotation-card purple">
                <div class="annotation-content">
                  <span class="badge">4</span>
                  <div class="annotation-text">
                    <h4 data-i18n="ann4Title">Dense(10, softmax)</h4>
                    <p data-i18n="ann4Text">10 output neurons — one for each digit (0–9). Softmax converts raw scores into probabilities that sum to 1.0, so the network effectively "votes" on which digit it sees.</p>
                  </div>
                </div>
              </div>
              <div class="annotation-card orange">
                <div class="annotation-content">
                  <span class="badge">5</span>
                  <div class="annotation-text">
                    <h4 data-i18n="ann5Title">Compile</h4>
                    <p data-i18n="ann5Text">Configures how the model learns. The loss function (SparseCategoricalCrossentropy) measures how wrong predictions are. Adam is an optimizer that adjusts weights to minimize that error.</p>
                  </div>
                </div>
              </div>
              <div class="annotation-card red">
                <div class="annotation-content">
                  <span class="badge">6</span>
                  <div class="annotation-text">
                    <h4 data-i18n="ann6Title">Train</h4>
                    <p data-i18n="ann6Text">The model sees the entire dataset 40 times (epochs). Each pass: it makes predictions, measures the error, and updates its weights to improve.</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- SECTION 2: Architecture -->
        <section class="section">
          <div>
            <h2 class="section-title" data-i18n="section2Title">Understanding the Architecture</h2>
            <p class="section-subtitle" data-i18n="section2Subtitle">A 4-layer neural network that recognizes handwritten digits</p>
          </div>

          <!-- Architecture Diagram -->
          <div class="arch-diagram">
            <div class="arch-box">
              <div class="arch-label" data-i18n="archInput">Input</div>
              <div class="arch-neurons">784</div>
              <div class="arch-sub">28 x 28 px</div>
            </div>
            <div class="arch-arrow">
              <div class="arch-arrow-line"></div>
              <svg class="arch-arrow-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </div>
            <div class="arch-box green">
              <div class="arch-label" data-i18n="archHidden1">Hidden 1</div>
              <div class="arch-neurons">64</div>
              <div class="arch-sub">ReLU</div>
            </div>
            <div class="arch-arrow">
              <div class="arch-arrow-line"></div>
              <svg class="arch-arrow-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </div>
            <div class="arch-box green">
              <div class="arch-label" data-i18n="archHidden2">Hidden 2</div>
              <div class="arch-neurons">32</div>
              <div class="arch-sub">ReLU</div>
            </div>
            <div class="arch-arrow">
              <div class="arch-arrow-line"></div>
              <svg class="arch-arrow-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
              </svg>
            </div>
            <div class="arch-box purple">
              <div class="arch-label" data-i18n="archOutput">Output</div>
              <div class="arch-neurons">10</div>
              <div class="arch-sub">Softmax</div>
            </div>
          </div>

          <!-- Concept Cards -->
          <div class="concept-grid">
            <div class="concept-card">
              <div class="concept-icon" style="background: rgba(59, 130, 246, 0.1); color: #60a5fa;">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h4a1 1 0 011 1v7a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM14 5a1 1 0 011-1h4a1 1 0 011 1v7a1 1 0 01-1 1h-4a1 1 0 01-1-1V5zM4 16a1 1 0 011-1h4a1 1 0 011 1v3a1 1 0 01-1 1H5a1 1 0 01-1-1v-3zM14 16a1 1 0 011-1h4a1 1 0 011 1v3a1 1 0 01-1 1h-4a1 1 0 01-1-1v-3z" />
                </svg>
              </div>
              <h3 class="concept-title" data-i18n="conceptDenseTitle">What is Dense?</h3>
              <p class="concept-text" data-i18n="conceptDenseText">In a Dense layer every neuron is connected to every neuron in the previous layer. With 784 inputs and 64 neurons, that means 50,176 individual connections — each with its own trainable weight.</p>
            </div>
            <div class="concept-card">
              <div class="concept-icon" style="background: rgba(34, 197, 94, 0.1); color: #34d399;">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
              </div>
              <h3 class="concept-title" data-i18n="conceptReLUTitle">What is ReLU?</h3>
              <p class="concept-text" data-i18n="conceptReLUText">ReLU (Rectified Linear Unit) is a simple activation function: if the input is negative it outputs 0, otherwise it passes the value unchanged. This introduces non-linearity, allowing the network to learn complex patterns.</p>
            </div>
            <div class="concept-card">
              <div class="concept-icon" style="background: rgba(168, 85, 247, 0.1); color: #a855f7;">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                </svg>
              </div>
              <h3 class="concept-title" data-i18n="conceptSoftmaxTitle">What is Softmax?</h3>
              <p class="concept-text" data-i18n="conceptSoftmaxText">Softmax converts a vector of raw scores into probabilities. If the output is [2.1, 0.5, 8.3, …], softmax ensures all values are positive and sum to exactly 1.0 — a proper probability distribution.</p>
            </div>
          </div>
        </section>

        <!-- SECTION 3: Pipeline -->
        <section class="section">
          <div>
            <h2 class="section-title" data-i18n="section3Title">What Happens When You Draw</h2>
            <p class="section-subtitle" data-i18n="section3Subtitle">From pixels to prediction in 6 steps</p>
          </div>

          <div class="pipeline-grid">
            <div class="pipeline-step">
              <div class="pipeline-icon" style="background: rgba(59, 130, 246, 0.1); color: #60a5fa;">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                </svg>
              </div>
              <div class="pipeline-num">1</div>
              <h4 class="pipeline-title" data-i18n="pipe1Title">Draw</h4>
              <p class="pipeline-text" data-i18n="pipe1Text">You draw on a 28×28 canvas. Each cell is a brightness from 0 to 255.</p>
            </div>
            <div class="pipeline-step">
              <div class="pipeline-icon" style="background: rgba(34, 211, 238, 0.1); color: #22d3ee;">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6zM16 13a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6z" />
                </svg>
              </div>
              <div class="pipeline-num">2</div>
              <h4 class="pipeline-title" data-i18n="pipe2Title">Flatten</h4>
              <p class="pipeline-text" data-i18n="pipe2Text">The 28×28 grid is reshaped into a single array of 784 values.</p>
            </div>
            <div class="pipeline-step">
              <div class="pipeline-icon" style="background: rgba(34, 197, 94, 0.1); color: #34d399;">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
                </svg>
              </div>
              <div class="pipeline-num">3</div>
              <h4 class="pipeline-title" data-i18n="pipe3Title">Normalize</h4>
              <p class="pipeline-text" data-i18n="pipe3Text">Each pixel is normalized: (pixel − 0.13) / 0.31, matching training preprocessing.</p>
            </div>
            <div class="pipeline-step">
              <div class="pipeline-icon" style="background: rgba(234, 179, 8, 0.1); color: #eab308;">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                </svg>
              </div>
              <div class="pipeline-num">4</div>
              <h4 class="pipeline-title" data-i18n="pipe4Title">Forward Pass</h4>
              <p class="pipeline-text" data-i18n="pipe4Text">Data flows through each layer: multiply by weights, add bias, apply activation.</p>
            </div>
            <div class="pipeline-step">
              <div class="pipeline-icon" style="background: rgba(251, 146, 60, 0.1); color: #fb923c;">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                </svg>
              </div>
              <div class="pipeline-num">5</div>
              <h4 class="pipeline-title" data-i18n="pipe5Title">Softmax</h4>
              <p class="pipeline-text" data-i18n="pipe5Text">The 10 raw scores are converted into probabilities that sum to 1.</p>
            </div>
            <div class="pipeline-step">
              <div class="pipeline-icon" style="background: rgba(168, 85, 247, 0.1); color: #a855f7;">
                <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
              </div>
              <div class="pipeline-num">6</div>
              <h4 class="pipeline-title" data-i18n="pipe6Title">Prediction</h4>
              <p class="pipeline-text" data-i18n="pipe6Text">The digit with the highest probability is the network's answer.</p>
            </div>
          </div>
        </section>

        <!-- SECTION 4: Key Concepts -->
        <section class="section">
          <div>
            <h2 class="section-title" data-i18n="section4Title">Key Concepts</h2>
            <p class="section-subtitle" data-i18n="section4Subtitle">Dive deeper into the building blocks</p>
          </div>

          <div style="display: flex; flex-direction: column; gap: 12px;">
            <div class="expandable-card" style="border-left-color: #3b82f6;">
              <button class="expandable-header" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'block' ? 'none' : 'block'; this.querySelector('.expandable-icon').style.transform = this.nextElementSibling.style.display === 'block' ? 'rotate(180deg)' : 'rotate(0deg)'">
                <span class="expandable-title" data-i18n="keyWeights">Weights & Biases</span>
                <svg class="expandable-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="transition: transform 0.2s;">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
              </button>
              <div class="expandable-content" style="display: none;" data-i18n="keyWeightsText">Weights are the learnable numbers on every connection between neurons. Each weight controls how much influence one neuron has on the next. Biases give each neuron an adjustable threshold — they shift the activation function left or right. Together, weights and biases are the "knowledge" the network acquires during training.</div>
            </div>
            <div class="expandable-card" style="border-left-color: #f97316;">
              <button class="expandable-header" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'block' ? 'none' : 'block'; this.querySelector('.expandable-icon').style.transform = this.nextElementSibling.style.display === 'block' ? 'rotate(180deg)' : 'rotate(0deg)'">
                <span class="expandable-title" data-i18n="keyLoss">Loss Function</span>
                <svg class="expandable-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="transition: transform 0.2s;">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
              </button>
              <div class="expandable-content" style="display: none;" data-i18n="keyLossText">Sparse Categorical Crossentropy measures how far the predicted probabilities are from the true label. If the correct digit is 7 and the model gives 90% confidence to 7, the loss is low. If it gives 10%, the loss is high. The goal of training is to minimize this number across all examples.</div>
            </div>
            <div class="expandable-card" style="border-left-color: #10b981;">
              <button class="expandable-header" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'block' ? 'none' : 'block'; this.querySelector('.expandable-icon').style.transform = this.nextElementSibling.style.display === 'block' ? 'rotate(180deg)' : 'rotate(0deg)'">
                <span class="expandable-title" data-i18n="keyAdam">Adam Optimizer</span>
                <svg class="expandable-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="transition: transform 0.2s;">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
              </button>
              <div class="expandable-content" style="display: none;" data-i18n="keyAdamText">Adam (Adaptive Moment Estimation) is a smart version of gradient descent. It maintains a moving average of both the gradients and their squared values, adapting the learning rate for each weight individually. This makes training faster and more stable than basic gradient descent.</div>
            </div>
            <div class="expandable-card" style="border-left-color: #a855f7;">
              <button class="expandable-header" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'block' ? 'none' : 'block'; this.querySelector('.expandable-icon').style.transform = this.nextElementSibling.style.display === 'block' ? 'rotate(180deg)' : 'rotate(0deg)'">
                <span class="expandable-title" data-i18n="keyEpochs">Epochs</span>
                <svg class="expandable-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="transition: transform 0.2s;">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
              </button>
              <div class="expandable-content" style="display: none;" data-i18n="keyEpochsText">One epoch means the model has seen every training example once. Training for 40 epochs means the model passes over the full dataset 40 times. With each pass, it refines its weights — but too many epochs can lead to overfitting, where the model memorizes training data instead of learning general patterns.</div>
            </div>
          </div>
        </section>
      </div>
    </div>
  </div>

  <!-- Three.js from CDN -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    // Import Three.js and OrbitControls
    import * as THREE from 'three'
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
    
    // Make THREE globally available
    window.THREE = THREE
    
    // Configuration
    const VISUALIZER_CONFIG = {
      weightUrl: 'https://raw.githubusercontent.com/DFin/Neural-Network-Visualisation/main/exports/mlp_weights/014_dataset-1x.json',
      maxConnectionsPerNeuron: 24,
      layerSpacing: 5.5,
      inputSpacing: 0.24,
      hiddenSpacing: 0.95,
      inputNodeSize: 0.18,
      hiddenNodeRadius: 0.22,
      connectionRadius: 0.005,
      connectionWeightThreshold: 0,
      brush: {
        drawRadius: 1.4,
        eraseRadius: 2.5,
        drawStrength: 0.95,
        eraseStrength: 0.95,
        softness: 0.3,
      },
    }

    const NORMALIZATION = { mean: 0.1307, std: 0.3081 }

    // Simulated accuracy progression during training (epoch 0-40)
    // This simulates how accuracy improves during training
    function getAccuracyForEpoch(epoch) {
      // Simulated accuracy curve: starts low, improves quickly, then plateaus
      if (epoch === 0) return 10.0
      if (epoch <= 5) return 10 + (epoch / 5) * 30  // 10% to 40%
      if (epoch <= 15) return 40 + ((epoch - 5) / 10) * 35  // 40% to 75%
      if (epoch <= 30) return 75 + ((epoch - 15) / 15) * 18  // 75% to 93%
      return 93 + ((epoch - 30) / 10) * 3.2  // 93% to 96.2%
    }
    
    function getAccuracyForHiddenNodes(hiddenNodes, epoch) {
      // Base accuracy from epoch
      const epochAccuracy = getAccuracyForEpoch(epoch)
      
      // Adjust based on hidden nodes: more nodes generally = better accuracy up to a point
      // Optimal around 64-128 nodes, too few (<32) or too many (>256) can reduce accuracy
      let nodeMultiplier = 1.0
      if (hiddenNodes < 32) {
        nodeMultiplier = 0.7 + (hiddenNodes / 32) * 0.3  // 70% to 100% for <32 nodes
      } else if (hiddenNodes <= 128) {
        nodeMultiplier = 1.0  // Optimal range
      } else if (hiddenNodes <= 256) {
        nodeMultiplier = 1.0 - ((hiddenNodes - 128) / 128) * 0.1  // Slight decrease for >128
      } else {
        nodeMultiplier = 0.9 - ((hiddenNodes - 256) / 256) * 0.2  // More decrease for >256
      }
      
      return epochAccuracy * nodeMultiplier
    }

    // Helper functions
    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value))
    }

    function softmax(values) {
      if (!values.length) return []
      const maxVal = Math.max(...values)
      const exps = values.map((value) => Math.exp(value - maxVal))
      const sum = exps.reduce((acc, value) => acc + value, 0)
      return exps.map((value) => (sum === 0 ? 0 : value / sum))
    }

    function maxAbsValue(values) {
      let max = 0
      for (let i = 0; i < values.length; i += 1) {
        const magnitude = Math.abs(values[i])
        if (magnitude > max) {
          max = magnitude
        }
      }
      return max
    }

    // Decode functions
    function decodeBase64ToUint8Array(base64) {
      const binary = atob(base64)
      const length = binary.length
      const bytes = new Uint8Array(length)
      for (let i = 0; i < length; i += 1) {
        bytes[i] = binary.charCodeAt(i)
      }
      return bytes
    }

    function float16ToFloat32(value) {
      const sign = (value & 0x8000) >> 15
      const exponent = (value & 0x7c00) >> 10
      const fraction = value & 0x03ff

      let result
      if (exponent === 0) {
        if (fraction === 0) {
          result = 0
        } else {
          result = (fraction / 0x400) * Math.pow(2, -14)
        }
      } else if (exponent === 0x1f) {
        result = fraction === 0 ? Number.POSITIVE_INFINITY : Number.NaN
      } else {
        result = (1 + fraction / 0x400) * Math.pow(2, exponent - 15)
      }

      return sign === 1 ? -result : result
    }

    function decodeFloat16Base64(base64, expectedLength) {
      const bytes = decodeBase64ToUint8Array(base64)
      if (bytes.byteLength % 2 !== 0) {
        throw new Error('Float16 data has invalid length.')
      }
      const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)
      const length = bytes.byteLength / 2
      if (Number.isFinite(expectedLength) && expectedLength > 0 && length !== expectedLength) {
        throw new Error(`Expected ${expectedLength} Float16 values, but got ${length}.`)
      }
      const result = new Float32Array(length)
      for (let index = 0; index < length; index += 1) {
        const half = view.getUint16(index * 2, true)
        result[index] = float16ToFloat32(half)
      }
      return result
    }

    async function fetchNetworkDefinition(url) {
      const response = await fetch(url, { cache: 'no-store' })
      if (!response.ok) {
        throw new Error(`Network weights could not be loaded (${response.status})`)
      }
      return response.json()
    }

    // Classes (continuing in next part due to length)
    class DigitSketchPad {
      constructor(container, rows, cols, options = {}) {
        if (!container) {
          throw new Error('Grid container not found.')
        }
        this.container = container
        this.rows = rows
        this.cols = cols
        this.values = new Float32Array(rows * cols)
        this.cells = []
        this.isDrawing = false
        this.activeMode = 'draw'
        this.onChange = null
        this.pendingChange = false
        this.interactionRow = null
        const defaultBrush = {
          drawRadius: 1.2,
          eraseRadius: 1.2,
          drawStrength: 0.85,
          eraseStrength: 0.8,
          softness: 0.5,
        }
        this.brush = Object.assign(defaultBrush, options.brush || {})
        this.buildGrid()
      }

      buildGrid() {
        this.gridElement = document.createElement('div')
        this.gridElement.style.display = 'grid'
        this.gridElement.style.gridTemplateColumns = `repeat(${this.cols}, 1fr)`
        this.gridElement.style.gridTemplateRows = `repeat(${this.rows}, 1fr)`
        this.gridElement.style.width = '280px'
        this.gridElement.style.height = '280px'
        this.gridElement.style.gap = '0'
        this.gridElement.style.border = '2px solid #374151'
        this.gridElement.style.borderRadius = '8px'
        this.gridElement.style.overflow = 'hidden'

        for (let i = 0; i < this.values.length; i += 1) {
          const cell = document.createElement('div')
          cell.dataset.index = String(i)
          cell.style.background = 'rgba(255, 255, 255, 0.05)'
          cell.style.border = 'none'
          cell.style.cursor = 'crosshair'
          this.gridElement.appendChild(cell)
          this.cells.push(cell)
        }

        this.container.innerHTML = ''
        const title = document.createElement('div')
        title.textContent = 'Draw digit'
        title.style.fontSize = '0.875rem'
        title.style.color = '#9ca3af'
        title.style.marginBottom = '8px'
        this.interactionRow = document.createElement('div')
        this.interactionRow.appendChild(this.gridElement)
        this.container.appendChild(title)
        this.container.appendChild(this.interactionRow)

        this.gridElement.addEventListener('pointerdown', (event) => this.handlePointerDown(event))
        this.gridElement.addEventListener('pointermove', (event) => this.handlePointerMove(event))
        window.addEventListener('pointerup', () => this.handlePointerUp())
        this.gridElement.addEventListener('contextmenu', (event) => event.preventDefault())
      }

      setChangeHandler(handler) {
        this.onChange = handler
      }

      handlePointerDown(event) {
        event.preventDefault()
        const isErase = event.button === 2 || event.buttons === 2
        this.activeMode = isErase ? 'erase' : 'draw'
        this.isDrawing = true
        this.applyPointer(event)
      }

      handlePointerMove(event) {
        if (!this.isDrawing) return
        this.applyPointer(event)
      }

      handlePointerUp() {
        this.isDrawing = false
      }

      applyPointer(event) {
        const element = document.elementFromPoint(event.clientX, event.clientY)
        if (!element) return
        const cell = element.closest('[data-index]')
        if (!cell) return
        const index = Number(cell.dataset.index)
        if (Number.isNaN(index)) return
        this.paintCell(index, this.activeMode === 'erase')
      }

      paintCell(index, erase = false) {
        const row = Math.floor(index / this.cols)
        const col = index % this.cols
        if (row < 0 || col < 0) return
        const changed = this.applyBrush(row, col, erase)
        if (changed) {
          this.scheduleChange()
        }
      }

      applyBrush(centerRow, centerCol, erase = false) {
        const radius = erase ? this.brush.eraseRadius : this.brush.drawRadius
        const strength = erase ? -this.brush.eraseStrength : this.brush.drawStrength
        const softness = clamp(this.brush.softness ?? 0.5, 0, 0.95)
        const span = Math.ceil(radius)
        let modified = false
        for (let row = centerRow - span; row <= centerRow + span; row += 1) {
          if (row < 0 || row >= this.rows) continue
          for (let col = centerCol - span; col <= centerCol + span; col += 1) {
            if (col < 0 || col >= this.cols) continue
            const distance = Math.hypot(row - centerRow, col - centerCol)
            if (distance > radius) continue
            const falloff = 1 - distance / radius
            if (falloff <= 0) continue
            const influence = Math.pow(falloff, 1 + softness * 2)
            const delta = strength * influence
            if (Math.abs(delta) < 1e-3) continue
            const cellIndex = row * this.cols + col
            const current = this.values[cellIndex]
            const nextValue = clamp(current + delta, 0, 1)
            if (nextValue === current) continue
            this.values[cellIndex] = nextValue
            this.updateCellVisual(cellIndex)
            modified = true
          }
        }
        return modified
      }

      updateCellVisual(index) {
        const cell = this.cells[index]
        if (!cell) return
        const value = this.values[index]
        if (value <= 0) {
          cell.style.background = 'rgba(255, 255, 255, 0.05)'
          return
        }
        const hue = 180 - value * 70
        const saturation = 70 + value * 25
        const lightness = 25 + value * 40
        cell.style.background = `hsl(${hue.toFixed(0)}, ${saturation.toFixed(0)}%, ${lightness.toFixed(0)}%)`
      }

      scheduleChange() {
        if (this.pendingChange) return
        this.pendingChange = true
        requestAnimationFrame(() => {
          this.pendingChange = false
          if (typeof this.onChange === 'function') {
            this.onChange()
          }
        })
      }

      getPixels() {
        return Float32Array.from(this.values)
      }

      clear() {
        this.values.fill(0)
        for (let i = 0; i < this.cells.length; i += 1) {
          this.updateCellVisual(i)
        }
        if (typeof this.onChange === 'function') {
          this.onChange()
        }
      }
    }

    class FeedForwardModel {
      constructor(definition) {
        if (!definition.layers?.length) {
          throw new Error('Network definition must contain layers.')
        }
        this.normalization = definition.normalization ?? { mean: 0, std: 1 }
        this.architecture = Array.isArray(definition.architecture)
          ? definition.architecture.slice()
          : this.computeArchitecture(definition.layers)
        this.layers = definition.layers.map((layer, index) => this.normaliseLayer(layer, index))
      }

      computeArchitecture(layers) {
        if (!layers.length) return []
        const architecture = []
        const firstLayer = layers[0]
        architecture.push(firstLayer.weights[0]?.length ?? 0)
        for (const layer of layers) {
          architecture.push(layer.biases.length)
        }
        return architecture
      }

      normaliseLayer(layer, index) {
        if (!layer || !Array.isArray(layer.weights) || layer.weights.length === 0) {
          throw new Error(`Layer ${index} is missing valid weight matrices.`)
        }
        const weights = layer.weights.map((row) => {
          if (row instanceof Float32Array) {
            return new Float32Array(row)
          }
          if (Array.isArray(row)) {
            return Float32Array.from(row)
          }
          throw new Error(`Layer ${index} contains an invalid weight row.`)
        })
        let biases
        if (layer.biases instanceof Float32Array) {
          biases = new Float32Array(layer.biases)
        } else if (Array.isArray(layer.biases)) {
          biases = Float32Array.from(layer.biases)
        } else {
          biases = new Float32Array(weights.length > 0 ? weights[0].length : 0)
        }
        return {
          name: typeof layer.name === 'string' ? layer.name : `dense_${index}`,
          activation: typeof layer.activation === 'string' ? layer.activation : 'relu',
          weights,
          biases,
        }
      }

      updateLayers(newLayers) {
        if (!Array.isArray(newLayers) || newLayers.length === 0) {
          throw new Error('New layers must be a non-empty array.')
        }
        this.layers = newLayers.map((layer, index) => this.normaliseLayer(layer, index))
        this.architecture = this.computeArchitecture(this.layers)
      }

      propagate(pixels) {
        const { mean, std } = this.normalization
        const input = new Float32Array(pixels.length)
        for (let i = 0; i < pixels.length; i += 1) {
          input[i] = (pixels[i] - mean) / std
        }

        const activations = [input]
        const preActivations = []
        let current = input

        for (const layer of this.layers) {
          const outSize = layer.biases.length
          const linear = new Float32Array(outSize)

          for (let neuron = 0; neuron < outSize; neuron += 1) {
            let sum = layer.biases[neuron]
            const weights = layer.weights[neuron]
            for (let source = 0; source < weights.length; source += 1) {
              sum += weights[source] * current[source]
            }
            linear[neuron] = sum
          }

          preActivations.push(linear)
          let activated
          if (layer.activation === 'relu') {
            activated = new Float32Array(outSize)
            for (let i = 0; i < outSize; i += 1) {
              activated[i] = linear[i] > 0 ? linear[i] : 0
            }
          } else {
            activated = linear.slice()
          }
          activations.push(activated)
          current = activated
        }

        return {
          normalizedInput: activations[0],
          activations,
          preActivations,
        }
      }
    }

    class ProbabilityPanel {
      constructor(container) {
        this.container = container
        this.rows = []
        if (!this.container) {
          throw new Error('Prediction chart container not found.')
        }
        this.build()
      }

      build() {
        this.container.innerHTML = ''
        const chartElement = document.createElement('div')
        chartElement.style.display = 'flex'
        chartElement.style.flexDirection = 'column'
        chartElement.style.gap = '8px'
        this.container.appendChild(chartElement)

        for (let digit = 0; digit < 10; digit += 1) {
          const row = document.createElement('div')
          row.style.display = 'flex'
          row.style.alignItems = 'center'
          row.style.gap = '12px'

          const label = document.createElement('span')
          label.style.width = '24px'
          label.style.fontSize = '0.875rem'
          label.style.fontWeight = '600'
          label.style.color = '#d1d5db'
          label.textContent = String(digit)

          const track = document.createElement('div')
          track.style.flex = '1'
          track.style.height = '24px'
          track.style.background = '#374151'
          track.style.borderRadius = '4px'
          track.style.overflow = 'hidden'
          track.style.position = 'relative'

          const bar = document.createElement('div')
          bar.style.height = '100%'
          bar.style.width = '0%'
          bar.style.transition = 'width 0.3s'
          bar.style.background = 'linear-gradient(to right, #3b82f6, #8b5cf6)'
          track.appendChild(bar)

          const value = document.createElement('span')
          value.style.width = '48px'
          value.style.textAlign = 'right'
          value.style.fontSize = '0.875rem'
          value.style.color = '#d1d5db'
          value.textContent = '0.0%'

          row.appendChild(label)
          row.appendChild(track)
          row.appendChild(value)
          chartElement.appendChild(row)
          this.rows.push({ bar, value })
        }
      }

      update(probabilities) {
        if (!probabilities.length) return
        const maxProb = Math.max(...probabilities)
        probabilities.forEach((prob, index) => {
          const clamped = Math.max(0, Math.min(1, prob))
          const entry = this.rows[index]
          if (!entry) return
          entry.bar.style.width = `${(clamped * 100).toFixed(1)}%`
          entry.value.textContent = `${(clamped * 100).toFixed(1)}%`
          if (clamped === maxProb) {
            entry.bar.style.background = 'linear-gradient(to right, #3b82f6, #8b5cf6)'
          } else {
            entry.bar.style.background = 'linear-gradient(to right, #4b5563, #6b7280)'
          }
        })
      }
    }

    // NeuralVisualizer class (simplified for performance)
    class NeuralVisualizer {
      constructor(mlp, options) {
        console.log('NeuralVisualizer constructor called with architecture:', mlp.architecture)
        this.mlp = mlp
        this.options = Object.assign({
          layerSpacing: 5.5,
          inputSpacing: 0.24,
          hiddenSpacing: 0.95,
          outputSpacing: 0.95,
          inputNodeSize: 0.18,
          hiddenNodeRadius: 0.22,
          maxConnectionsPerNeuron: 24,
          connectionRadius: 0.005,
          connectionWeightThreshold: 0,
        }, options || {})
        this.container = this.options.container || document.getElementById('threeContainer')
        this.layerMeshes = []
        this.connectionGroups = []
        this.tempObject = new THREE.Object3D()
        this.tempColor = new THREE.Color()
        this.animationFrameId = null
        this.initThreeScene()
        this.buildLayers()
        this.buildConnections()
        this.animate()
      }

      initThreeScene() {
        if (!this.container) return

        this.scene = new THREE.Scene()
        this.scene.background = null

        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight)
        this.container.appendChild(this.renderer.domElement)

        this.camera = new THREE.PerspectiveCamera(
          45,
          this.container.clientWidth / this.container.clientHeight,
          0.1,
          200
        )
        this.camera.position.set(-15, 0, 15)

        this.controls = new OrbitControls(this.camera, this.renderer.domElement)
        this.controls.enableDamping = true
        this.controls.dampingFactor = 0.08
        // Disable zoom with scroll wheel to allow page scrolling
        this.controls.enableZoom = false
        this.controls.minDistance = 8
        this.controls.maxDistance = 52
        this.controls.target.set(0, 0, 0)

        const ambient = new THREE.AmbientLight(0xffffff, 1.2)
        this.scene.add(ambient)
        const hemisphere = new THREE.HemisphereLight(0xffffff, 0x1a1d2e, 0.9)
        hemisphere.position.set(0, 20, 0)
        this.scene.add(hemisphere)
        const directional = new THREE.DirectionalLight(0xffffff, 1.4)
        directional.position.set(18, 26, 24)
        this.scene.add(directional)
        const fillLight = new THREE.DirectionalLight(0xa8c5ff, 0.8)
        fillLight.position.set(-20, 18, -18)
        this.scene.add(fillLight)
        const rimLight = new THREE.PointLight(0x88a4ff, 0.6, 60, 1.6)
        rimLight.position.set(0, 12, -24)
        this.scene.add(rimLight)

        window.addEventListener('resize', () => this.handleResize())
      }

      handleResize() {
        if (!this.container || !this.camera || !this.renderer) return
        const width = this.container.clientWidth
        const height = this.container.clientHeight
        this.renderer.setSize(width, height)
        this.camera.aspect = width / height
        this.camera.updateProjectionMatrix()
      }

      computeLayerPositions(layerIndex, neuronCount, layerX) {
        const positions = []
        const isOutputLayer = layerIndex === this.mlp.architecture.length - 1
        if (layerIndex === 0) {
          const spacing = this.options.inputSpacing
          let rows = 28, cols = 28
          if (neuronCount !== 28 * 28) {
            cols = Math.ceil(Math.sqrt(neuronCount))
            rows = Math.ceil(neuronCount / cols)
          }
          const height = (rows - 1) * spacing
          const width = (cols - 1) * spacing
          let filled = 0
          for (let row = 0; row < rows && filled < neuronCount; row += 1) {
            for (let col = 0; col < cols && filled < neuronCount; col += 1) {
              const y = height / 2 - row * spacing
              const z = -width / 2 + col * spacing
              positions.push(new THREE.Vector3(layerX, y, z))
              filled += 1
            }
          }
        } else if (isOutputLayer) {
          const spacing = this.options.outputSpacing ?? this.options.hiddenSpacing
          const height = (neuronCount - 1) * spacing
          for (let index = 0; index < neuronCount; index += 1) {
            const y = height / 2 - index * spacing
            positions.push(new THREE.Vector3(layerX, y, 0))
          }
        } else {
          const spacing = this.options.hiddenSpacing
          const cols = Math.max(1, Math.ceil(Math.sqrt(neuronCount)))
          const rows = Math.ceil(neuronCount / cols)
          const height = (rows - 1) * spacing
          const width = (cols - 1) * spacing
          for (let index = 0; index < neuronCount; index += 1) {
            const row = Math.floor(index / cols)
            const col = index % cols
            const y = height / 2 - row * spacing
            const z = -width / 2 + col * spacing
            positions.push(new THREE.Vector3(layerX, y, z))
          }
        }
        return positions
      }

      buildLayers() {
        const inputGeometry = new THREE.BoxGeometry(
          this.options.inputNodeSize,
          this.options.inputNodeSize,
          this.options.inputNodeSize
        )
        const hiddenGeometry = new THREE.SphereGeometry(this.options.hiddenNodeRadius, 16, 16)
        const hiddenBaseMaterial = new THREE.MeshBasicMaterial()
        hiddenBaseMaterial.toneMapped = false

        const layerCount = this.mlp.architecture.length
        const totalWidth = (layerCount - 1) * this.options.layerSpacing
        const startX = -totalWidth / 2

        this.mlp.architecture.forEach((neuronCount, layerIndex) => {
          const layerX = startX + layerIndex * this.options.layerSpacing
          const positions = this.computeLayerPositions(layerIndex, neuronCount, layerX)
          const isOutputLayer = layerIndex === layerCount - 1

          if (layerIndex === 0) {
            const material = new THREE.MeshLambertMaterial()
            material.emissive.setRGB(0.08, 0.08, 0.08)
            const mesh = new THREE.InstancedMesh(inputGeometry, material, neuronCount)
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage)
            const colorAttribute = new THREE.InstancedBufferAttribute(
              new Float32Array(neuronCount * 3),
              3
            )
            colorAttribute.setUsage(THREE.DynamicDrawUsage)
            mesh.instanceColor = colorAttribute

            positions.forEach((position, instanceIndex) => {
              this.tempObject.position.copy(position)
              this.tempObject.updateMatrix()
              mesh.setMatrixAt(instanceIndex, this.tempObject.matrix)
              // Input layer: white (no use initially) — paso 1: solo valores, sin vertexColors
              mesh.setColorAt(instanceIndex, this.tempColor.setRGB(1, 1, 1))
            })

            mesh.instanceMatrix.needsUpdate = true
            mesh.instanceColor.needsUpdate = true
            this.scene.add(mesh)
            this.layerMeshes.push({ mesh, positions, type: 'input', layerIndex })
          } else {
            const material = hiddenBaseMaterial.clone()
            const geometry = hiddenGeometry.clone()
            const mesh = new THREE.InstancedMesh(geometry, material, neuronCount)
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage)
            const colorAttribute = new THREE.InstancedBufferAttribute(
              new Float32Array(neuronCount * 3),
              3
            )
            colorAttribute.setUsage(THREE.DynamicDrawUsage)
            mesh.instanceColor = colorAttribute

            positions.forEach((position, instanceIndex) => {
              this.tempObject.position.copy(position)
              this.tempObject.updateMatrix()
              mesh.setMatrixAt(instanceIndex, this.tempObject.matrix)
              // All layers: white (no use initially) — paso 1
              mesh.setColorAt(instanceIndex, this.tempColor.setRGB(1, 1, 1))
            })

            mesh.instanceMatrix.needsUpdate = true
            mesh.instanceColor.needsUpdate = true
            this.scene.add(mesh)
            const layerType = isOutputLayer ? 'output' : 'hidden'
            this.layerMeshes.push({ mesh, positions, type: layerType, layerIndex })
          }
        })
      }

      findImportantConnections(layer, layerIndex = -1) {
        // For input layer (layerIndex === 0), show all connections (784)
        // For other layers, use the configured limit
        const isInputLayer = layerIndex === 0
        const limit = isInputLayer ? layer.weights[0]?.length || 784 : this.options.maxConnectionsPerNeuron
        const minMagnitude = Math.max(0, this.options.connectionWeightThreshold ?? 0)
        const selected = []
        let maxAbsWeight = 0
        for (let target = 0; target < layer.weights.length; target += 1) {
          const row = layer.weights[target]
          const candidates = []
          for (let source = 0; source < row.length; source += 1) {
            const weight = row[source]
            if (!Number.isFinite(weight)) continue
            const magnitude = Math.abs(weight)
            candidates.push({ sourceIndex: source, targetIndex: target, weight, magnitude })
            if (magnitude > maxAbsWeight) maxAbsWeight = magnitude
          }
          
          if (isInputLayer) {
            // For input layer, include all connections (or all above threshold)
            for (let i = 0; i < candidates.length; i += 1) {
              const candidate = candidates[i]
              if (candidate.magnitude >= minMagnitude) {
                selected.push({
                  sourceIndex: candidate.sourceIndex,
                  targetIndex: candidate.targetIndex,
                  weight: candidate.weight,
                })
              }
            }
          } else {
            // For other layers, sort by magnitude and take top N
            candidates.sort((a, b) => b.magnitude - a.magnitude)
            const take = Math.min(limit, candidates.length)
            for (let i = 0; i < take; i += 1) {
              const candidate = candidates[i]
              if (candidate.magnitude < minMagnitude) break
              selected.push({
                sourceIndex: candidate.sourceIndex,
                targetIndex: candidate.targetIndex,
                weight: candidate.weight,
              })
            }
          }
        }
        return { selected, maxAbsWeight }
      }

      buildConnections() {
        const connectionRadius = this.options.connectionRadius ?? 0.005
        const baseGeometry = new THREE.CylinderGeometry(connectionRadius, connectionRadius, 1, 10, 1, true)
        const material = new THREE.MeshLambertMaterial()

        this.mlp.layers.forEach((layer, layerIndex) => {
          const { selected } = this.findImportantConnections(layer, layerIndex)
          if (!selected.length) return

          const mesh = new THREE.InstancedMesh(baseGeometry.clone(), material.clone(), selected.length)
          mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage)
          const colorAttribute = new THREE.InstancedBufferAttribute(
            new Float32Array(selected.length * 3),
            3
          )
          colorAttribute.setUsage(THREE.DynamicDrawUsage)
          mesh.instanceColor = colorAttribute

          selected.forEach((connection, instanceIndex) => {
            const sourcePosition = this.layerMeshes[layerIndex].positions[connection.sourceIndex]
            const targetPosition = this.layerMeshes[layerIndex + 1].positions[connection.targetIndex]
            const direction = targetPosition.clone().sub(sourcePosition)
            const length = direction.length()
            const midpoint = sourcePosition.clone().addScaledVector(direction, 0.5)

            this.tempObject.position.copy(midpoint)
            const quaternion = new THREE.Quaternion().setFromUnitVectors(
              new THREE.Vector3(0, 1, 0),
              direction.clone().normalize()
            )
            this.tempObject.scale.set(1, length, 1)
            this.tempObject.quaternion.copy(quaternion)
            this.tempObject.updateMatrix()
            mesh.setMatrixAt(instanceIndex, this.tempObject.matrix)
            // Initial connection color: white (no use initially) — paso 1
            mesh.setColorAt(instanceIndex, this.tempColor.setRGB(1, 1, 1))
          })

          mesh.instanceMatrix.needsUpdate = true
          mesh.instanceColor.needsUpdate = true
          this.scene.add(mesh)
          this.connectionGroups.push({
            mesh,
            connections: selected,
            sourceLayer: layerIndex,
          })
        })
      }

      applyNodeColors(layer, values, scale, layerIndex) {
        const { mesh, type } = layer
        if (type === 'input') {
          // Input layer: Red (no use) to Green (high use)
          for (let i = 0; i < values.length; i += 1) {
            const value = clamp(values[i], 0, 1)
            // White to Green (paso 1): (1-t, 1, 1-t)
            this.tempColor.setRGB(1 - value, 1, 1 - value)
            mesh.setColorAt(i, this.tempColor)
          }
          mesh.instanceColor.needsUpdate = true
          return
        }

        const safeScale = scale > 1e-6 ? scale : 1
        for (let i = 0; i < values.length; i += 1) {
          const value = values[i]
          const normalized = clamp(value / safeScale, 0, 1)
          
          // All layers: White to Green (paso 1)
          this.tempColor.setRGB(1 - normalized, 1, 1 - normalized)
          mesh.setColorAt(i, this.tempColor)
        }
        mesh.instanceColor.needsUpdate = true
      }

      applyConnectionColors(group, sourceValues) {
        const contributions = new Float32Array(group.connections.length)
        let maxContribution = 0
        group.connections.forEach((connection, index) => {
          const activation = sourceValues[connection.sourceIndex] ?? 0
          const contribution = activation * connection.weight
          contributions[index] = contribution
          const magnitude = Math.abs(contribution)
          if (magnitude > maxContribution) maxContribution = magnitude
        })
        const scale = maxContribution > 1e-6 ? maxContribution : 1
        group.connections.forEach((connection, index) => {
          const magnitude = Math.abs(contributions[index] / scale)
          const normalized = clamp(magnitude, 0, 1)
          
          // White (no use) to Green (high use) — paso 1
          if (normalized < 1e-3) {
            this.tempColor.setRGB(1, 1, 1)
          } else {
            this.tempColor.setRGB(1 - normalized, 1, 1 - normalized)
          }
          group.mesh.setColorAt(index, this.tempColor)
        })
        group.mesh.instanceColor.needsUpdate = true
      }

      update(displayActivations, networkActivations = displayActivations) {
        this.layerMeshes.forEach((layer, layerIndex) => {
          const values = displayActivations[layerIndex]
          if (!values) return
          const scale = layerIndex === 0 ? 1 : maxAbsValue(displayActivations[layerIndex])
          this.applyNodeColors(layer, values, scale || 1, layerIndex)
        })

        this.connectionGroups.forEach((group) => {
          const sourceValues = networkActivations[group.sourceLayer]
          if (!sourceValues) return
          this.applyConnectionColors(group, sourceValues)
        })
      }

      animate() {
        const renderFrame = () => {
          if (this.controls) {
            this.controls.update()
          }
          if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera)
          }
          this.animationFrameId = requestAnimationFrame(renderFrame)
        }
        renderFrame()
      }
    }

    // Main initialization
    async function initializeVisualizer() {
      try {
        const weightDefinitionUrl = new URL(VISUALIZER_CONFIG.weightUrl, window.location.href)
        const rawDefinition = await fetchNetworkDefinition(weightDefinitionUrl.toString())
        
        let definition = rawDefinition
        let architecture = null
        let normalization = NORMALIZATION
        
        if (rawDefinition.layers && Array.isArray(rawDefinition.layers) && !rawDefinition.network) {
          architecture = [784]
          rawDefinition.layers.forEach((layer) => {
            if (layer.weights?.shape && Array.isArray(layer.weights.shape) && layer.weights.shape.length >= 1) {
              const [outputSize] = layer.weights.shape
              architecture.push(outputSize)
            }
          })
          
          definition = {
            network: {
              architecture,
              normalization,
              layers: rawDefinition.layers.map((layer, idx) => ({
                name: layer.name || `dense_${idx}`,
                activation: layer.activation || 'relu',
                weights: layer.weights,
                bias: layer.bias || layer.biases,
              })),
            },
          }
        }
        
        if (!definition?.network) {
          throw new Error('Invalid network definition.')
        }

        let initialSnapshot = null
        if (definition.network?.layers) {
          const layers = definition.network.layers.map((layer, idx) => {
            const weightInfo = layer.weights
            const biasInfo = layer.bias || layer.biases
            if (!weightInfo || !weightInfo.data || !weightInfo.shape) {
              throw new Error(`Layer ${idx} missing weight data`)
            }
            const weightArray = decodeFloat16Base64(weightInfo.data, weightInfo.shape[0] * weightInfo.shape[1])
            const weights = []
            const [rows, cols] = weightInfo.shape
            for (let r = 0; r < rows; r++) {
              weights.push(weightArray.slice(r * cols, (r + 1) * cols))
            }
            let biases
            if (biasInfo?.data) {
              const biasSize = biasInfo.shape?.[0] || rows
              const biasArray = decodeFloat16Base64(biasInfo.data, biasSize)
              biases = Array.from(biasArray)
            } else {
              biases = new Array(rows).fill(0)
            }
            return {
              name: layer.name || `dense_${idx}`,
              activation: layer.activation || 'relu',
              weights,
              biases,
            }
          })
          initialSnapshot = { layers }
        }

        if (!initialSnapshot) {
          throw new Error('No valid snapshot found.')
        }

        // Store original fully-trained weights (epoch 40)
        let originalLayers = JSON.parse(JSON.stringify(initialSnapshot.layers))
        let currentArchitectureLayers = JSON.parse(JSON.stringify(initialSnapshot.layers)) // Current architecture layers
        
        // Create a seeded random number generator for deterministic results
        function seededRandom(seed) {
          let value = seed
          return function() {
            value = (value * 9301 + 49297) % 233280
            return value / 233280
          }
        }
        
        // Pre-generate random values for each weight/bias to ensure determinism
        const randomValues = {}
        function getRandomValue(layerIdx, rowIdx, colIdx, seed) {
          const key = `${layerIdx}_${rowIdx}_${colIdx}`
          if (!randomValues[key]) {
            const rng = seededRandom(seed + layerIdx * 1000 + rowIdx * 100 + colIdx)
            randomValues[key] = rng()
          }
          return randomValues[key]
        }
        
        const biasRandomValues = {}
        function getBiasRandomValue(layerIdx, biasIdx, seed) {
          const key = `${layerIdx}_${biasIdx}`
          if (!biasRandomValues[key]) {
            const rng = seededRandom(seed + layerIdx * 1000 + biasIdx)
            biasRandomValues[key] = rng()
          }
          return biasRandomValues[key]
        }
        
        // Function to simulate weights at a given epoch
        // At epoch 0: weights are mostly random (poor performance)
        // At epoch 40: weights are fully trained (best performance)
        function getWeightsForEpoch(epoch) {
          const trainingProgress = Math.max(0, Math.min(1, epoch / 40)) // Clamp between 0 and 1
          const randomFactor = 1 - trainingProgress // Higher for early epochs
          
          // Use current architecture layers instead of original layers
          return currentArchitectureLayers.map((layer, layerIdx) => {
            const modifiedWeights = layer.weights.map((row, rowIdx) => {
              return row.map((weight, colIdx) => {
                // Mix trained weights with deterministic random noise based on epoch
                // Early epochs: more random, late epochs: more trained
                const randomNoise = (getRandomValue(layerIdx, rowIdx, colIdx, 12345) - 0.5) * 0.5 * randomFactor
                const trainedWeight = weight * trainingProgress
                const randomWeight = (getRandomValue(layerIdx, rowIdx, colIdx, 67890) - 0.5) * 2 * randomFactor
                return trainedWeight + randomWeight + randomNoise
              })
            })
            
            const modifiedBiases = layer.biases.map((bias, biasIdx) => {
              const randomNoise = (getBiasRandomValue(layerIdx, biasIdx, 11111) - 0.5) * 0.3 * randomFactor
              const trainedBias = bias * trainingProgress
              const randomBias = (getBiasRandomValue(layerIdx, biasIdx, 22222) - 0.5) * 1 * randomFactor
              return trainedBias + randomBias + randomNoise
            })
            
            return {
              name: layer.name,
              activation: layer.activation,
              weights: modifiedWeights,
              biases: modifiedBiases,
            }
          })
        }

        // Initialize model with fully trained weights
        let currentEpoch = 40
        let currentHiddenNodes = 64 // Default hidden layer size
        let neuralModel = new FeedForwardModel({
          normalization: definition.network.normalization || NORMALIZATION,
          architecture: definition.network.architecture || architecture,
          layers: initialSnapshot.layers,
        })
        
        // Function to generate weights for a new architecture with different hidden node count
        // Adapts the original trained weights to the new architecture
        function getWeightsForHiddenNodes(hiddenNodes) {
          // Original architecture: 784 -> 64 -> 32 -> 10
          // New architecture: 784 -> hiddenNodes -> Math.floor(hiddenNodes/2) -> 10
          const originalHidden1 = 64
          const originalHidden2 = 32
          const newHidden1 = hiddenNodes
          const newHidden2 = Math.floor(hiddenNodes / 2)
          
          const newArchitecture = [
            784, // input
            newHidden1, // hidden1
            newHidden2, // hidden2
            10 // output
          ]
          
          const originalLayer0 = originalLayers[0] // 784 -> 64
          const originalLayer1 = originalLayers[1] // 64 -> 32
          const originalLayer2 = originalLayers[2] // 32 -> 10
          
          const newLayers = []
          
          // Layer 1: 784 -> newHidden1 (adapt from 784 -> 64)
          const layer1Weights = []
          const layer1Biases = []
          
          for (let i = 0; i < newHidden1; i++) {
            // Map new node to original node (with wrapping/replication)
            const origNodeIdx = i % originalHidden1
            const origWeights = originalLayer0.weights[origNodeIdx]
            const origBias = originalLayer0.biases[origNodeIdx]
            
            if (!origWeights) {
              console.error('origWeights is undefined for index', origNodeIdx, 'in layer 0')
              continue
            }
            
            // Copy weights from original node (handle both arrays and Float32Arrays)
            let weightsCopy
            const expectedWeightLength = 784 // Input layer has 784 features
            try {
              // Check if it's a typed array (Float32Array, Uint8Array, etc.)
              if (origWeights && typeof origWeights.length === 'number' && origWeights.constructor && origWeights.constructor.name.includes('Array')) {
                weightsCopy = Array.from(origWeights)
              } else if (Array.isArray(origWeights)) {
                weightsCopy = [...origWeights]
              } else if (origWeights && typeof origWeights.length === 'number') {
                // Handle array-like objects
                weightsCopy = Array.from(origWeights)
              } else {
                console.error('origWeights is not iterable:', origWeights, 'type:', typeof origWeights, 'constructor:', origWeights?.constructor?.name)
                weightsCopy = new Array(expectedWeightLength).fill(0)
              }
            } catch (e) {
              console.error('Error copying weights:', e, 'origWeights:', origWeights)
              weightsCopy = new Array(expectedWeightLength).fill(0)
            }
            
            // Ensure the array has the correct length
            if (weightsCopy.length !== expectedWeightLength) {
              if (weightsCopy.length < expectedWeightLength) {
                // Pad with zeros if too short
                weightsCopy = [...weightsCopy, ...new Array(expectedWeightLength - weightsCopy.length).fill(0)]
              } else {
                // Truncate if too long
                weightsCopy = weightsCopy.slice(0, expectedWeightLength)
              }
            }
            
            layer1Weights.push(weightsCopy)
            layer1Biases.push(origBias)
          }
          
          newLayers.push({
            name: 'dense_0',
            activation: originalLayer0.activation || 'relu',
            weights: layer1Weights,
            biases: layer1Biases,
          })
          
          // Layer 2: newHidden1 -> newHidden2 (adapt from 64 -> 32)
          const layer2Weights = []
          const layer2Biases = []
          
          for (let i = 0; i < newHidden2; i++) {
            const row = []
            const origNodeIdx = i % originalHidden2
            const origWeights = originalLayer1.weights[origNodeIdx]
            const origBias = originalLayer1.biases[origNodeIdx]
            
            // Convert to array if Float32Array or other typed array
            let origWeightsArray
            try {
              if (origWeights && typeof origWeights.length === 'number' && origWeights.constructor && origWeights.constructor.name.includes('Array')) {
                origWeightsArray = Array.from(origWeights)
              } else if (Array.isArray(origWeights)) {
                origWeightsArray = origWeights
              } else {
                origWeightsArray = origWeights
              }
            } catch (e) {
              console.error('Error converting origWeights to array:', e)
              origWeightsArray = []
            }
            
            // Adapt weights: map from newHidden1 inputs to original 64 inputs
            for (let j = 0; j < newHidden1; j++) {
              const origInputIdx = j % originalHidden1
              row.push(origWeightsArray[origInputIdx])
            }
            
            layer2Weights.push(row)
            layer2Biases.push(origBias)
          }
          
          newLayers.push({
            name: 'dense_1',
            activation: originalLayer1.activation || 'relu',
            weights: layer2Weights,
            biases: layer2Biases,
          })
          
          // Layer 3: newHidden2 -> 10 (adapt from 32 -> 10)
          const layer3Weights = []
          const layer3Biases = []
          
          for (let i = 0; i < 10; i++) {
            const row = []
            const origWeights = originalLayer2.weights[i]
            const origBias = originalLayer2.biases[i]
            
            // Convert to array if Float32Array or other typed array
            let origWeightsArray
            try {
              if (origWeights && typeof origWeights.length === 'number' && origWeights.constructor && origWeights.constructor.name.includes('Array')) {
                origWeightsArray = Array.from(origWeights)
              } else if (Array.isArray(origWeights)) {
                origWeightsArray = origWeights
              } else {
                origWeightsArray = origWeights
              }
            } catch (e) {
              console.error('Error converting origWeights to array:', e)
              origWeightsArray = []
            }
            
            // Adapt weights: map from newHidden2 inputs to original 32 inputs
            for (let j = 0; j < newHidden2; j++) {
              const origInputIdx = j % originalHidden2
              row.push(origWeightsArray[origInputIdx])
            }
            
            layer3Weights.push(row)
            layer3Biases.push(origBias)
          }
          
          newLayers.push({
            name: 'dense_2',
            activation: originalLayer2.activation || 'relu',
            weights: layer3Weights,
            biases: layer3Biases,
          })
          
          return {
            architecture: newArchitecture,
            layers: newLayers,
          }
        }
        
        // Function to update model for new hidden node count
        function updateModelForHiddenNodes(hiddenNodes) {
          console.log('Updating model for hidden nodes:', hiddenNodes)
          const newArch = getWeightsForHiddenNodes(hiddenNodes)
          
          console.log('New architecture:', newArch.architecture)
          console.log('New layers:', newArch.layers.map(l => ({ name: l.name, weights: l.weights.length, biases: l.biases.length })))
          
          // Update current architecture layers FIRST, before calling getWeightsForEpoch
          currentArchitectureLayers = JSON.parse(JSON.stringify(newArch.layers))
          
          // Apply epoch-based modifications using the new architecture
          const epochLayers = getWeightsForEpoch(currentEpoch)
          
          console.log('Epoch layers count:', epochLayers.length)
          console.log('Epoch layer sizes:', epochLayers.map(l => ({ weights: l.weights.length, biases: l.biases.length })))
          
          // Verify architecture matches
          const expectedArch = newArch.architecture
          const actualArch = [
            epochLayers[0].weights[0].length, // input size
            epochLayers[0].weights.length,   // hidden1 size
            epochLayers[1].weights.length,   // hidden2 size
            epochLayers[2].weights.length    // output size
          ]
          console.log('Expected architecture:', expectedArch)
          console.log('Actual architecture from layers:', actualArch)
          
          // Create new model with new architecture and epoch-modified weights
          // Make sure architecture is explicitly set
          neuralModel = new FeedForwardModel({
            normalization: definition.network.normalization || NORMALIZATION,
            architecture: newArch.architecture, // Explicitly set architecture
            layers: epochLayers,
          })
          
          // Force architecture to match (in case FeedForwardModel recalculates it incorrectly)
          neuralModel.architecture = newArch.architecture.slice()
          
          console.log('Model architecture after creation:', neuralModel.architecture)
          console.log('Model layers:', neuralModel.layers.map(l => ({ weights: l.weights.length, biases: l.biases.length })))
          
          // Rebuild the 3D visualization with new architecture
          rebuildVisualization()
        }
        
        // Helper function to rebuild the 3D visualization
        function rebuildVisualization() {
          const threeContainer = document.getElementById('threeContainer')
          if (threeContainer && neuralModel) {
            console.log('Rebuilding visualization with architecture:', neuralModel.architecture)
            
            // Stop any existing animation
            if (neuralScene && neuralScene.animate) {
              // Cancel animation frame if possible
              if (neuralScene.animationFrameId) {
                cancelAnimationFrame(neuralScene.animationFrameId)
              }
            }
            
            // Dispose of Three.js resources if they exist
            if (neuralScene) {
              if (neuralScene.scene) {
                // Dispose of all meshes and geometries
                neuralScene.scene.traverse((object) => {
                  if (object.geometry) object.geometry.dispose()
                  if (object.material) {
                    if (Array.isArray(object.material)) {
                      object.material.forEach(mat => mat.dispose())
                    } else {
                      object.material.dispose()
                    }
                  }
                })
              }
              if (neuralScene.renderer) {
                neuralScene.renderer.dispose()
              }
            }
            
            // Clear old visualization completely
            threeContainer.innerHTML = ''
            
            // Small delay to ensure cleanup is complete
            requestAnimationFrame(() => {
              // Create new visualization with current model
              neuralScene = new NeuralVisualizer(neuralModel, {
                container: threeContainer,
                layerSpacing: VISUALIZER_CONFIG.layerSpacing,
                maxConnectionsPerNeuron: VISUALIZER_CONFIG.maxConnectionsPerNeuron,
                inputSpacing: VISUALIZER_CONFIG.inputSpacing,
                hiddenSpacing: VISUALIZER_CONFIG.hiddenSpacing,
                inputNodeSize: VISUALIZER_CONFIG.inputNodeSize,
                hiddenNodeRadius: VISUALIZER_CONFIG.hiddenNodeRadius,
                connectionRadius: VISUALIZER_CONFIG.connectionRadius,
                connectionWeightThreshold: VISUALIZER_CONFIG.connectionWeightThreshold,
              })
              
              console.log('Visualization created, architecture:', neuralScene.mlp?.architecture)
              console.log('Model architecture:', neuralModel.architecture)
              
              // Restart animation loop
              neuralScene.animate()
              
              // Immediately update with current drawing if there is one
              const rawInput = digitCanvas.getPixels()
              const hasDrawing = rawInput.some(val => val > 0)
              if (hasDrawing) {
                refreshNetworkState()
              }
            })
          }
        }

        const gridContainerElement = document.getElementById('gridContainer')
        const digitCanvas = new DigitSketchPad(gridContainerElement, 28, 28, {
          brush: VISUALIZER_CONFIG.brush,
        })

        const probabilityPanel = new ProbabilityPanel(document.getElementById('predictionChart'))

        let neuralScene = new NeuralVisualizer(neuralModel, {
          container: document.getElementById('threeContainer'),
          layerSpacing: VISUALIZER_CONFIG.layerSpacing,
          maxConnectionsPerNeuron: VISUALIZER_CONFIG.maxConnectionsPerNeuron,
          inputSpacing: VISUALIZER_CONFIG.inputSpacing,
          hiddenSpacing: VISUALIZER_CONFIG.hiddenSpacing,
          inputNodeSize: VISUALIZER_CONFIG.inputNodeSize,
          hiddenNodeRadius: VISUALIZER_CONFIG.hiddenNodeRadius,
          connectionRadius: VISUALIZER_CONFIG.connectionRadius,
          connectionWeightThreshold: VISUALIZER_CONFIG.connectionWeightThreshold,
        })

        const resetBtn = document.getElementById('resetBtn')
        if (resetBtn) {
          resetBtn.addEventListener('click', () => {
            digitCanvas.clear()
            refreshNetworkState()
          })
        }

        // Epoch slider setup
        const epochSlider = document.getElementById('epochSlider')
        const epochValue = document.getElementById('epochValue')
        const accuracyValue = document.getElementById('accuracyValue')
        
        function updateEpochDisplay(epoch) {
          if (epochValue) epochValue.textContent = epoch
          const accuracy = getAccuracyForHiddenNodes(currentHiddenNodes, epoch)
          if (accuracyValue) accuracyValue.textContent = accuracy.toFixed(1) + '%'
        }
        
        // Hidden nodes slider setup
        const hiddenNodesSlider = document.getElementById('hiddenNodesSlider')
        const hiddenNodesValue = document.getElementById('hiddenNodesValue')
        const hiddenNodesAccuracyValue = document.getElementById('hiddenNodesAccuracyValue')
        
        function updateHiddenNodesDisplay(hiddenNodes) {
          if (hiddenNodesValue) hiddenNodesValue.textContent = hiddenNodes
          const accuracy = getAccuracyForHiddenNodes(hiddenNodes, currentEpoch)
          if (hiddenNodesAccuracyValue) hiddenNodesAccuracyValue.textContent = accuracy.toFixed(1) + '%'
        }
        
        if (hiddenNodesSlider) {
          hiddenNodesSlider.addEventListener('input', (e) => {
            const hiddenNodes = parseInt(e.target.value)
            currentHiddenNodes = hiddenNodes
            updateHiddenNodesDisplay(hiddenNodes)
            // Also update epoch display to reflect new accuracy
            updateEpochDisplay(currentEpoch)
            // Don't update visualization automatically - wait for button click
          })
          // Initialize display
          updateHiddenNodesDisplay(64)
        }
        
        // Track the last applied architecture to know when to rebuild
        let lastAppliedHiddenNodes = 64
        let lastAppliedEpoch = 40
        
        // Function to update visualization with current settings
        function updateVisualization() {
          // Always update if architecture changed
          if (currentHiddenNodes !== lastAppliedHiddenNodes) {
            // Architecture changed - rebuild with new architecture and current epoch
            updateModelForHiddenNodes(currentHiddenNodes)
            lastAppliedHiddenNodes = currentHiddenNodes
            lastAppliedEpoch = currentEpoch
          } else if (currentEpoch !== lastAppliedEpoch) {
            // Architecture unchanged but epoch changed - just update epoch
            updateModelForEpoch(currentEpoch)
            lastAppliedEpoch = currentEpoch
          } else {
            // Force rebuild even if nothing changed (user clicked button)
            // This ensures the visualization is always up to date
            if (currentHiddenNodes !== 64) {
              updateModelForHiddenNodes(currentHiddenNodes)
            } else {
              updateModelForEpoch(currentEpoch)
            }
          }
        }
        
        // Update Visualization Button
        const updateVisualizationBtn = document.getElementById('updateVisualizationBtn')
        if (updateVisualizationBtn) {
          updateVisualizationBtn.addEventListener('click', () => {
            updateVisualization()
          })
        }

        function updateModelForEpoch(epoch) {
          // Update model with weights corresponding to this epoch
          const epochLayers = getWeightsForEpoch(epoch)
          neuralModel.updateLayers(epochLayers)
          
          // Rebuild the 3D visualization with new weights
          rebuildVisualization()
        }

        if (epochSlider) {
          epochSlider.addEventListener('input', (e) => {
            const epoch = parseInt(e.target.value)
            currentEpoch = epoch
            updateEpochDisplay(epoch)
            // Also update hidden nodes display to reflect new accuracy
            updateHiddenNodesDisplay(currentHiddenNodes)
            // Don't update visualization automatically - wait for button click
          })
          // Initialize display
          updateEpochDisplay(40)
        }

        function refreshNetworkState() {
          const rawInput = digitCanvas.getPixels()
          const hasDrawing = rawInput.some(val => val > 0)
          const propagation = neuralModel.propagate(rawInput)
          const displayActivations = propagation.activations.slice()
          if (displayActivations.length > 0) {
            displayActivations[0] = rawInput
          }

          let probabilities
          if (!hasDrawing) {
            // Canvas en blanco: 10% para cada dígito (0-9)
            probabilities = new Float32Array(10)
            for (let i = 0; i < 10; i += 1) probabilities[i] = 0.1
          } else {
            const logitsTyped =
              propagation.preActivations.length > 0
                ? propagation.preActivations[propagation.preActivations.length - 1]
                : new Float32Array(0)
            probabilities =
              logitsTyped.length > 0
                ? Float32Array.from(softmax(Array.from(logitsTyped)))
                : new Float32Array(0)
          }

          if (probabilities.length && displayActivations.length > 1) {
            displayActivations[displayActivations.length - 1] = probabilities
          }

          let networkActivations = propagation.activations
          if (probabilities.length) {
            networkActivations = propagation.activations.slice()
            if (networkActivations.length > 1) {
              networkActivations[networkActivations.length - 1] = probabilities
            }
          }

          neuralScene.update(displayActivations, networkActivations)
          probabilityPanel.update(Array.from(probabilities))
        }

        digitCanvas.setChangeHandler(() => refreshNetworkState())

        refreshNetworkState()
      } catch (error) {
        console.error('Error initializing visualizer:', error)
        var errDiv = document.createElement('div')
        errDiv.style.cssText = 'padding: 48px; text-align: center; color: #ef4444;'
        errDiv.innerHTML = '<h2 data-i18n="errorTitle">Error loading visualization</h2><p>' + (error.message || '') + '</p><p style="margin-top: 16px; font-size: 0.875rem; color: #9ca3af;" data-i18n="errorConsole">Check the console for details.</p>'
        document.body.innerHTML = ''
        document.body.appendChild(errDiv)
        if (window.applyNNTranslations && window.getNNLang) window.applyNNTranslations(window.getNNLang())
      }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeVisualizer)
    } else {
      initializeVisualizer()
    }
  </script>
  <script>
    (function () {
      var LANG_KEY = 'portfolio-language'
      var NN = {
        en: {
          pageTitle: 'MNIST Neural Network Visualization',
          heroTitle: 'MNIST Neural Network Visualization',
          heroSubtitle: 'Draw a digit and watch how activations propagate through the network',
          drawing: 'Drawing',
          clear: 'Clear',
          hintDraw: 'Click and drag to draw (right-click to erase)',
          prediction: 'Prediction',
          trainingEpoch: 'Training Epoch',
          epoch: 'Epoch',
          accuracy: 'Accuracy',
          hintEpoch: 'Adjust the epoch to see how training improves accuracy',
          hiddenLayerNodes: 'Hidden Layer Nodes',
          hiddenNodes: 'Hidden Nodes',
          hintHidden: 'Adjust hidden layer size to see its impact on accuracy',
          updateBtn: 'Update and Recalculate',
          hintUpdate: 'Click to update the 3D visualization and recalculate predictions',
          learnMore: 'Learn More',
          section1Title: 'How This Network Was Trained',
          section1Subtitle: 'The actual TensorFlow / Keras code used to build and train the model',
          codeLang: 'Python / TensorFlow',
          ann1Title: 'Input Layer',
          ann1Text: 'Each 28×28 pixel drawing is flattened into a vector of 784 numbers. This is the entry point of the network.',
          ann2Title: 'Dense(64, relu)',
          ann2Text: 'A Dense (fully connected) layer: every one of the 64 neurons receives input from ALL 784 pixels. "Dense" means every possible connection exists. ReLU activation: if the value is negative → 0, if positive → passes through unchanged.',
          ann3Title: 'Dense(32, relu)',
          ann3Text: 'Second hidden layer with 32 neurons, each connected to all 64 neurons from the previous layer. The network learns progressively more abstract patterns at each layer.',
          ann4Title: 'Dense(10, softmax)',
          ann4Text: '10 output neurons — one for each digit (0–9). Softmax converts raw scores into probabilities that sum to 1.0, so the network effectively "votes" on which digit it sees.',
          ann5Title: 'Compile',
          ann5Text: 'Configures how the model learns. The loss function (SparseCategoricalCrossentropy) measures how wrong predictions are. Adam is an optimizer that adjusts weights to minimize that error.',
          ann6Title: 'Train',
          ann6Text: 'The model sees the entire dataset 40 times (epochs). Each pass: it makes predictions, measures the error, and updates its weights to improve.',
          section2Title: 'Understanding the Architecture',
          section2Subtitle: 'A 4-layer neural network that recognizes handwritten digits',
          archInput: 'Input',
          archHidden1: 'Hidden 1',
          archHidden2: 'Hidden 2',
          archOutput: 'Output',
          conceptDenseTitle: 'What is Dense?',
          conceptDenseText: 'In a Dense layer every neuron is connected to every neuron in the previous layer. With 784 inputs and 64 neurons, that means 50,176 individual connections — each with its own trainable weight.',
          conceptReLUTitle: 'What is ReLU?',
          conceptReLUText: 'ReLU (Rectified Linear Unit) is a simple activation function: if the input is negative it outputs 0, otherwise it passes the value unchanged. This introduces non-linearity, allowing the network to learn complex patterns.',
          conceptSoftmaxTitle: 'What is Softmax?',
          conceptSoftmaxText: 'Softmax converts a vector of raw scores into probabilities. If the output is [2.1, 0.5, 8.3, …], softmax ensures all values are positive and sum to exactly 1.0 — a proper probability distribution.',
          section3Title: 'What Happens When You Draw',
          section3Subtitle: 'From pixels to prediction in 6 steps',
          pipe1Title: 'Draw',
          pipe1Text: 'You draw on a 28×28 canvas. Each cell is a brightness from 0 to 255.',
          pipe2Title: 'Flatten',
          pipe2Text: 'The 28×28 grid is reshaped into a single array of 784 values.',
          pipe3Title: 'Normalize',
          pipe3Text: 'Each pixel is normalized: (pixel − 0.13) / 0.31, matching training preprocessing.',
          pipe4Title: 'Forward Pass',
          pipe4Text: 'Data flows through each layer: multiply by weights, add bias, apply activation.',
          pipe5Title: 'Softmax',
          pipe5Text: 'The 10 raw scores are converted into probabilities that sum to 1.',
          pipe6Title: 'Prediction',
          pipe6Text: "The digit with the highest probability is the network's answer.",
          section4Title: 'Key Concepts',
          section4Subtitle: 'Dive deeper into the building blocks',
          keyWeights: 'Weights & Biases',
          keyWeightsText: 'Weights are the learnable numbers on every connection between neurons. Each weight controls how much influence one neuron has on the next. Biases give each neuron an adjustable threshold — they shift the activation function left or right. Together, weights and biases are the "knowledge" the network acquires during training.',
          keyLoss: 'Loss Function',
          keyLossText: 'Sparse Categorical Crossentropy measures how far the predicted probabilities are from the true label. If the correct digit is 7 and the model gives 90% confidence to 7, the loss is low. If it gives 10%, the loss is high. The goal of training is to minimize this number across all examples.',
          keyAdam: 'Adam Optimizer',
          keyAdamText: 'Adam (Adaptive Moment Estimation) is a smart version of gradient descent. It maintains a moving average of both the gradients and their squared values, adapting the learning rate for each weight individually. This makes training faster and more stable than basic gradient descent.',
          keyEpochs: 'Epochs',
          keyEpochsText: 'One epoch means the model has seen every training example once. Training for 40 epochs means the model passes over the full dataset 40 times. With each pass, it refines its weights — but too many epochs can lead to overfitting, where the model memorizes training data instead of learning general patterns.',
          errorTitle: 'Error loading visualization',
          errorConsole: 'Check the console for details.',
          langMobileLabel: 'Idioma / Language'
        },
        es: {
          pageTitle: 'Visualización de red neuronal MNIST',
          heroTitle: 'Visualización de red neuronal MNIST',
          heroSubtitle: 'Dibuja un dígito y observa cómo se propagan las activaciones por la red',
          drawing: 'Dibujo',
          clear: 'Borrar',
          hintDraw: 'Haz clic y arrastra para dibujar (clic derecho para borrar)',
          prediction: 'Predicción',
          trainingEpoch: 'Época de entrenamiento',
          epoch: 'Época',
          accuracy: 'Precisión',
          hintEpoch: 'Ajusta la época para ver cómo mejora la precisión con el entrenamiento',
          hiddenLayerNodes: 'Nodos de la capa oculta',
          hiddenNodes: 'Nodos ocultos',
          hintHidden: 'Ajusta el tamaño de la capa oculta para ver su impacto en la precisión',
          updateBtn: 'Actualizar y recalcular',
          hintUpdate: 'Haz clic para actualizar la visualización 3D y recalcular las predicciones',
          learnMore: 'Saber más',
          section1Title: 'Cómo se entrenó esta red',
          section1Subtitle: 'El código real en TensorFlow / Keras usado para construir y entrenar el modelo',
          codeLang: 'Python / TensorFlow',
          ann1Title: 'Capa de entrada',
          ann1Text: 'Cada dibujo de 28×28 píxeles se aplana en un vector de 784 números. Es la entrada de la red.',
          ann2Title: 'Dense(64, relu)',
          ann2Text: 'Capa Dense (totalmente conectada): cada uno de los 64 neuronas recibe entrada de los 784 píxeles. "Dense" significa que existe cada conexión posible. Activación ReLU: si el valor es negativo → 0, si es positivo → se deja igual.',
          ann3Title: 'Dense(32, relu)',
          ann3Text: 'Segunda capa oculta con 32 neuronas, cada una conectada a las 64 de la capa anterior. La red aprende patrones cada vez más abstractos en cada capa.',
          ann4Title: 'Dense(10, softmax)',
          ann4Text: '10 neuronas de salida, una por cada dígito (0–9). Softmax convierte las puntuaciones en probabilidades que suman 1.0; la red "vota" qué dígito cree ver.',
          ann5Title: 'Compile',
          ann5Text: 'Configura cómo aprende el modelo. La función de pérdida (SparseCategoricalCrossentropy) mide el error de las predicciones. Adam es un optimizador que ajusta los pesos para minimizar ese error.',
          ann6Title: 'Train',
          ann6Text: 'El modelo ve todo el dataset 40 veces (épocas). En cada pasada: predice, mide el error y actualiza los pesos para mejorar.',
          section2Title: 'Entender la arquitectura',
          section2Subtitle: 'Una red neuronal de 4 capas que reconoce dígitos escritos a mano',
          archInput: 'Entrada',
          archHidden1: 'Oculta 1',
          archHidden2: 'Oculta 2',
          archOutput: 'Salida',
          conceptDenseTitle: '¿Qué es Dense?',
          conceptDenseText: 'En una capa Dense cada neurona está conectada a todas las de la capa anterior. Con 784 entradas y 64 neuronas hay 50.176 conexiones, cada una con su peso entrenable.',
          conceptReLUTitle: '¿Qué es ReLU?',
          conceptReLUText: 'ReLU (Unidad Lineal Rectificada) es una función de activación simple: si la entrada es negativa devuelve 0; si no, el valor pasa igual. Introduce no linealidad y permite aprender patrones complejos.',
          conceptSoftmaxTitle: '¿Qué es Softmax?',
          conceptSoftmaxText: 'Softmax convierte un vector de puntuaciones en probabilidades. Si la salida es [2.1, 0.5, 8.3, …], softmax hace que los valores sean positivos y sumen 1.0.',
          section3Title: 'Qué ocurre cuando dibujas',
          section3Subtitle: 'De píxeles a predicción en 6 pasos',
          pipe1Title: 'Dibujar',
          pipe1Text: 'Dibujas en un lienzo 28×28. Cada celda es un brillo de 0 a 255.',
          pipe2Title: 'Aplanar',
          pipe2Text: 'La cuadrícula 28×28 se convierte en un único array de 784 valores.',
          pipe3Title: 'Normalizar',
          pipe3Text: 'Cada píxel se normaliza: (píxel − 0.13) / 0.31, igual que en el entrenamiento.',
          pipe4Title: 'Forward pass',
          pipe4Text: 'Los datos pasan por cada capa: multiplicar por pesos, sumar bias, aplicar activación.',
          pipe5Title: 'Softmax',
          pipe5Text: 'Las 10 puntuaciones se convierten en probabilidades que suman 1.',
          pipe6Title: 'Predicción',
          pipe6Text: 'El dígito con mayor probabilidad es la respuesta de la red.',
          section4Title: 'Conceptos clave',
          section4Subtitle: 'Profundiza en los bloques básicos',
          keyWeights: 'Pesos y biases',
          keyWeightsText: 'Los pesos son los números que se aprenden en cada conexión. Cada peso controla la influencia de una neurona en la siguiente. Los biases dan a cada neurona un umbral; desplazan la función de activación. Juntos son el "conocimiento" de la red.',
          keyLoss: 'Función de pérdida',
          keyLossText: 'Sparse Categorical Crossentropy mide cuánto se alejan las probabilidades predichas de la etiqueta real. Si el dígito correcto es 7 y el modelo da 90% al 7, la pérdida es baja. Si da 10%, es alta. El entrenamiento minimiza este valor.',
          keyAdam: 'Optimizador Adam',
          keyAdamText: 'Adam (Adaptive Moment Estimation) es una versión mejorada del descenso por gradiente. Mantiene medias móviles de los gradientes y de sus cuadrados, adaptando la tasa de aprendizaje por peso. Entrenamiento más rápido y estable.',
          keyEpochs: 'Épocas',
          keyEpochsText: 'Una época significa que el modelo ha visto cada ejemplo una vez. 40 épocas = 40 pasadas completas al dataset. En cada pasada refina los pesos; demasiadas épocas pueden causar overfitting (memorizar en vez de generalizar).',
          errorTitle: 'Error al cargar la visualización',
          errorConsole: 'Revisa la consola para más detalles.',
          langMobileLabel: 'Idioma / Language'
        },
        ca: {
          pageTitle: 'Visualització de xarxa neuronal MNIST',
          heroTitle: 'Visualització de xarxa neuronal MNIST',
          heroSubtitle: 'Dibuixa un dígit i observa com es propaguen les activacions per la xarxa',
          drawing: 'Dibuix',
          clear: 'Esborrar',
          hintDraw: 'Clica i arrossega per dibuixar (clic dret per esborrar)',
          prediction: 'Predicció',
          trainingEpoch: 'Època d\'entrenament',
          epoch: 'Època',
          accuracy: 'Precisió',
          hintEpoch: 'Ajusta l\'època per veure com millora la precisió amb l\'entrenament',
          hiddenLayerNodes: 'Nodes de la capa oculta',
          hiddenNodes: 'Nodes ocults',
          hintHidden: 'Ajusta la mida de la capa oculta per veure el seu impacte en la precisió',
          updateBtn: 'Actualitzar i recalcular',
          hintUpdate: 'Clica per actualitzar la visualització 3D i recalcular les prediccions',
          learnMore: 'Saber-ne més',
          section1Title: 'Com es va entrenar aquesta xarxa',
          section1Subtitle: 'El codi real en TensorFlow / Keras utilitzat per construir i entrenar el model',
          codeLang: 'Python / TensorFlow',
          ann1Title: 'Capa d\'entrada',
          ann1Text: 'Cada dibuix de 28×28 píxels s\'aplana en un vector de 784 nombres. És l\'entrada de la xarxa.',
          ann2Title: 'Dense(64, relu)',
          ann2Text: 'Capa Dense (totalment connectada): cada una de les 64 neurones rep entrada dels 784 píxels. "Dense" vol dir que existeix cada connexió possible. Activació ReLU: si el valor és negatiu → 0; si és positiu → es deixa igual.',
          ann3Title: 'Dense(32, relu)',
          ann3Text: 'Segona capa oculta amb 32 neurones, connectades a les 64 de la capa anterior. La xarxa aprèn patrons cada cop més abstractes.',
          ann4Title: 'Dense(10, softmax)',
          ann4Text: '10 neurones de sortida, una per cada dígit (0–9). Softmax converteix les puntuacions en probabilitats que sumen 1.0.',
          ann5Title: 'Compile',
          ann5Text: 'Configura com aprèn el model. La funció de pèrdua (SparseCategoricalCrossentropy) mesura l\'error de les prediccions. Adam és un optimitzador que ajusta els pesos per minimitzar aquest error.',
          ann6Title: 'Train',
          ann6Text: 'El model veu tot el dataset 40 vegades (èpoques). A cada passada: prediu, mesura l\'error i actualitza els pesos.',
          section2Title: 'Entendre l\'arquitectura',
          section2Subtitle: 'Una xarxa neuronal de 4 capes que reconeix dígits escrits a mà',
          archInput: 'Entrada',
          archHidden1: 'Oculta 1',
          archHidden2: 'Oculta 2',
          archOutput: 'Sortida',
          conceptDenseTitle: 'Què és Dense?',
          conceptDenseText: 'En una capa Dense cada neurona està connectada a totes les de la capa anterior. Amb 784 entrades i 64 neurones hi ha 50.176 connexions, cadascuna amb el seu pes entrenable.',
          conceptReLUTitle: 'Què és ReLU?',
          conceptReLUText: 'ReLU (Unitat Lineal Rectificada) és una funció d\'activació simple: si l\'entrada és negativa retorna 0; si no, el valor passa igual. Introdueix no linealitat.',
          conceptSoftmaxTitle: 'Què és Softmax?',
          conceptSoftmaxText: 'Softmax converteix un vector de puntuacions en probabilitats que sumen 1.0.',
          section3Title: 'Què passa quan dibuixes',
          section3Subtitle: 'De píxels a predicció en 6 passos',
          pipe1Title: 'Dibuixar',
          pipe1Text: 'Dibuixes en un llenç 28×28. Cada cel·la és una brillantor de 0 a 255.',
          pipe2Title: 'Aplanar',
          pipe2Text: 'La graella 28×28 es converteix en un array de 784 valors.',
          pipe3Title: 'Normalitzar',
          pipe3Text: 'Cada píxel es normalitza: (píxel − 0.13) / 0.31, com a l\'entrenament.',
          pipe4Title: 'Forward pass',
          pipe4Text: 'Les dades passen per cada capa: multiplicar per pesos, sumar bias, aplicar activació.',
          pipe5Title: 'Softmax',
          pipe5Text: 'Les 10 puntuacions es converteixen en probabilitats que sumen 1.',
          pipe6Title: 'Predicció',
          pipe6Text: 'El dígit amb més probabilitat és la resposta de la xarxa.',
          section4Title: 'Conceptes clau',
          section4Subtitle: 'Approfundeix en els blocs bàsics',
          keyWeights: 'Pesos i biases',
          keyWeightsText: 'Els pesos són els nombres que s\'aprenen en cada connexió. Els biases donen a cada neurona un llindar. Junts són el "coneixement" de la xarxa.',
          keyLoss: 'Funció de pèrdua',
          keyLossText: 'Sparse Categorical Crossentropy mesura com s\'allunyen les probabilitats de l\'etiqueta real. L\'entrenament minimitza aquest valor.',
          keyAdam: 'Optimitzador Adam',
          keyAdamText: 'Adam manté mitjanes mòbils dels gradients i adapta la taxa d\'aprenentatge per pes. Entrenament més ràpid i estable.',
          keyEpochs: 'Èpoques',
          keyEpochsText: 'Una època vol dir que el model ha vist cada exemple una vegada. Masses èpoques poden causar overfitting.',
          errorTitle: 'Error en carregar la visualització',
          errorConsole: 'Revisa la consola per a més detalls.',
          langMobileLabel: 'Idioma / Language'
        }
      }
      function getNNLang() {
        var s = localStorage.getItem(LANG_KEY)
        return (s === 'es' || s === 'ca') ? s : 'en'
      }
      function applyTranslations(lang) {
        var t = NN[lang] || NN.en
        document.querySelectorAll('[data-i18n]').forEach(function (el) {
          var key = el.getAttribute('data-i18n')
          var val = t[key]
          if (val != null) el.textContent = val
        })
        document.title = t.pageTitle
        document.documentElement.lang = lang === 'es' ? 'es' : lang === 'ca' ? 'ca' : 'en'
      }
      window.addEventListener('nn-lang-change', function (e) { if (e.detail && e.detail.lang) applyTranslations(e.detail.lang) })
      window.applyNNTranslations = applyTranslations
      window.getNNLang = getNNLang
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function () { applyTranslations(getNNLang()) })
      } else {
        applyTranslations(getNNLang())
      }
    })()
  </script>
</body>
</html>
